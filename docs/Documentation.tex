%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=2,mathnumfig,mathnumsep={.}]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{GloMarGridding}
\date{May 22, 2025}
\release{0.3.0}
\author{NOC Surface Processes}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}
\sphinxstepscope


\chapter{Getting Started}
\label{\detokenize{getting_started:getting-started}}\label{\detokenize{getting_started::doc}}

\section{Installation}
\label{\detokenize{getting_started:installation}}

\subsection{Via Pip}
\label{\detokenize{getting_started:via-pip}}
\sphinxAtStartPar
GloMarGridding is not available on PyPI, however it can be installed via pip with the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip install GloMarGridding@git+ssh://git@git.noc.ac.uk/nocsurfaceprocesses/glomar\PYGZus{}gridding.git}
\end{sphinxVerbatim}


\subsection{From Source}
\label{\detokenize{getting_started:from-source}}
\sphinxAtStartPar
Alternatively, you can clone the repository and install using pip (or conda if preferred).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{git clone git@git.noc.ac.uk/nocsurfaceprocesses/glomar\PYGZus{}gridding.git}
\PYG{g+go}{cd glomar\PYGZus{}gridding}
\PYG{g+go}{python \PYGZhy{}m venv venv}
\PYG{g+go}{source venv/bin/activate}
\PYG{g+go}{pip install \PYGZhy{}e .}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Credits}
\label{\detokenize{authors:credits}}\label{\detokenize{authors::doc}}

\section{Development Lead}
\label{\detokenize{authors:development-lead}}\begin{itemize}
\item {}
\sphinxAtStartPar
Agnieszka Faulkner \textless{}\sphinxhref{mailto:agfaul@noc.ac.uk}{agfaul@noc.ac.uk}\textgreater{} \sphinxhref{git.noc.ac.uk/agfaul}{@agfaul}

\item {}
\sphinxAtStartPar
Joseph T. Siddons \textless{}\sphinxhref{mailto:josidd@noc.ac.uk}{josidd@noc.ac.uk}\textgreater{} \sphinxhref{git.noc.ac.uk/josidd}{@josidd}

\end{itemize}


\section{Contributoring Developers}
\label{\detokenize{authors:contributoring-developers}}\begin{itemize}
\item {}
\sphinxAtStartPar
Steven Chan \textless{}\sphinxhref{mailto:stchan@noc.ac.uk}{stchan@noc.ac.uk}\textgreater{} \sphinxhref{git.noc.ac.uk/stchan}{@stchan}

\item {}
\sphinxAtStartPar
Richard C. Cornes \textless{}\sphinxhref{mailto:rcornes@noc.ac.uk}{rcornes@noc.ac.uk}\textgreater{} \sphinxhref{git.noc.ac.uk/ricorne}{@ricorne}

\item {}
\sphinxAtStartPar
Elizabeth C. Kent \textless{}\sphinxhref{mailto:eck@noc.ac.uk}{eck@noc.ac.uk}\textgreater{} \sphinxhref{git.noc.ac.uk/eck}{@eck}

\end{itemize}

\sphinxstepscope


\chapter{Users Guide}
\label{\detokenize{users_guide:module-glomar_gridding.grid}}\label{\detokenize{users_guide:users-guide}}\label{\detokenize{users_guide::doc}}\index{module@\spxentry{module}!glomar\_gridding.grid@\spxentry{glomar\_gridding.grid}}\index{glomar\_gridding.grid@\spxentry{glomar\_gridding.grid}!module@\spxentry{module}}

\section{Grid}
\label{\detokenize{users_guide:grid}}
\sphinxAtStartPar
Functions for creating grids and mapping observations to a grid
\index{assign\_to\_grid() (in module glomar\_gridding.grid)@\spxentry{assign\_to\_grid()}\spxextra{in module glomar\_gridding.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.grid.assign_to_grid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.grid.}}\sphinxbfcode{\sphinxupquote{assign\_to\_grid}}}
{\sphinxparam{\DUrole{n}{values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_grid}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_value}\DUrole{o}{=}\DUrole{default_value}{nan}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Assign a vector of values to a grid, using a list of grid index values. The
default value for grid values is 0.0.

\sphinxAtStartPar
Optionally, if the grid is a mask, apply the mask to the output grid.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{pl.Series}}) \textendash{} The values to map onto the output grid.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{pl.Series}}) \textendash{} The 1d index of the grid (assuming “C” style ravelling) for each value.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} The grid used to define the output grid.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Optionally use values in the grid to mask the output grid.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} The value in the grid to use for masking the output grid.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{out\_grid} \textendash{} A new grid containing the values mapped onto the grid.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.DataArray

\end{description}\end{quote}

\end{fulllineitems}

\index{cross\_coords() (in module glomar\_gridding.grid)@\spxentry{cross\_coords()}\spxextra{in module glomar\_gridding.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.grid.cross_coords}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.grid.}}\sphinxbfcode{\sphinxupquote{cross\_coords}}}
{\sphinxparam{\DUrole{n}{coords}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lat\_coord}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lon\_coord}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Combine a set of coordinates into a cross\sphinxhyphen{}product, for example to construct
a coordinate system for a distance matrix.
\begin{description}
\sphinxlineitem{For example a coordinate system defined by:}
\sphinxAtStartPar
lat = {[}0, 1{]},
lon = {[}4, 5{]},

\sphinxlineitem{would yield a new coordinate system defined by:}
\sphinxAtStartPar
index\_1 = {[}0, 1, 2, 3{]}
index\_2 = {[}0, 1, 2, 3{]}
lat\_1 = {[}0, 0, 1, 1{]}
lon\_1 = {[}4, 5, 4, 5{]}
lat\_2 = {[}0, 0, 1, 1{]}
lon\_2 = {[}4, 5, 4, 5{]}

\end{description}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.Coordinates}}) \textendash{} The set of coordinates to combine, or cross. This should be of length
2 and have names defined by \sphinxtitleref{lat\_coord} and \sphinxtitleref{lon\_coord} input arguments.
The ordering of the coordinates will define the cross ordering.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lat\_coord}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the latitude coordinate.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lon\_coord}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the longitude coordinate.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{cross\_coords} \textendash{} The new crossed coordinates, including index, and each of the input
coordinates, for each dimension.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.Coordinates

\end{description}\end{quote}

\end{fulllineitems}

\index{grid\_from\_resolution() (in module glomar\_gridding.grid)@\spxentry{grid\_from\_resolution()}\spxextra{in module glomar\_gridding.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.grid.grid_from_resolution}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.grid.}}\sphinxbfcode{\sphinxupquote{grid\_from\_resolution}}}
{\sphinxparam{\DUrole{n}{resolution}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bounds}}\sphinxparamcomma \sphinxparam{\DUrole{n}{coord\_names}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Generate a grid from a resolution value, or a list of resolutions for
given boundaries and coordinate names.

\sphinxAtStartPar
Note that all list inputs must have the same length, the ordering of values
in the lists is assumed align.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{resolution}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Resolution of the grid. Can be a single resolution value that will be
applied to all coordinates, or a list of values mapping a resolution
value to each of the coordinates.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list of bounds of the form \sphinxtitleref{(lower\_bound, upper\_bound)} indicating
the bounding box of the returned grid

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coord\_names}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} List of coordinate names

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{grid} \textendash{} The grid defined by the resolution and bounding box.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.DataArray:

\end{description}\end{quote}

\end{fulllineitems}

\index{grid\_to\_distance\_matrix() (in module glomar\_gridding.grid)@\spxentry{grid\_to\_distance\_matrix()}\spxextra{in module glomar\_gridding.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.grid.grid_to_distance_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.grid.}}\sphinxbfcode{\sphinxupquote{grid\_to\_distance\_matrix}}}
{\sphinxparam{\DUrole{n}{grid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dist\_func=\textless{}function haversine\_distance\_from\_frame\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lat\_coord=\textquotesingle{}lat\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lon\_coord=\textquotesingle{}lon\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate a distance matrix between all positions in a grid. Orientation of
latitude and longitude will be maintained in the returned distance matrix.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} A 2\sphinxhyphen{}d grid containing latitude and longitude indexes specified in
decimal degrees.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}) \textendash{} Distance function to use to compute pairwise distances. See
glomar\_gridding.distances.calculate\_distance\_matrix for more
information.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lat\_coord}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the latitude coordinate in the input grid.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lon\_coord}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the longitude coordinate in the input grid.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{dist} \textendash{} A DataArray containing the distance matrix with coordinate system
defined with grid cell index (“index\_1” and “index\_2”). The coordinates
of the original grid are also kept as coordinates related to each
index (the coordinate names are suffixed with “\_1” or “\_2”
respectively).

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.DataArray

\end{description}\end{quote}

\end{fulllineitems}

\index{map\_to\_grid() (in module glomar\_gridding.grid)@\spxentry{map\_to\_grid()}\spxextra{in module glomar\_gridding.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.grid.map_to_grid}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.grid.}}\sphinxbfcode{\sphinxupquote{map\_to\_grid}}}
{\sphinxparam{\DUrole{n}{obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_coords}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}lat\textquotesingle{}, \textquotesingle{}lon\textquotesingle{}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid\_coords}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}latitude\textquotesingle{}, \textquotesingle{}longitude\textquotesingle{}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sort}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{add\_grid\_pts}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid\_prefix}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}grid\_\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Align an observation dataframe to a grid defined by an xarray DataArray.

\sphinxAtStartPar
Maps observations to the nearest grid\sphinxhyphen{}point, and sorts the data by the
1d index of the DataArray in a row\sphinxhyphen{}major format.

\sphinxAtStartPar
The grid defined by the latitude and longitude coordinates of the input
DataArray is then used as the output grid of the Gridding process.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} The observational DataFrame containing positional data with latitude,
longitude values within the \sphinxtitleref{obs\_latname} and \sphinxtitleref{obs\_lonname} columns
respectively. Observations are mapped to the nearest grid\sphinxhyphen{}point in the
grid.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} Contains the grid coordinates to map observations to.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Names of the column containing positional values in the input
observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Names of the coordinates in the input grid DataArray used to define the
grid.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sort}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Sort the observational DataFrame by the grid index

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally filter the grid and DataFrame to fall within spatial bounds.
This list must have the same size and ordering as \sphinxtitleref{obs\_coords} and
\sphinxtitleref{grid\_coords} arguments.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{add\_grid\_pts}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Add the grid positional information to the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_prefix}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Prefix to use for the new grid columns in the observational DataFrame.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{obs} \textendash{} Containing additional \sphinxtitleref{grid\_*}, and \sphinxtitleref{grid\_idx} values
indicating the positions and grid index of the observation
respectively. The DataFrame is also sorted (ascendingly) by the
\sphinxtitleref{grid\_idx} columns for consistency with the gridding functions.

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.variogram@\spxentry{glomar\_gridding.variogram}}\index{glomar\_gridding.variogram@\spxentry{glomar\_gridding.variogram}!module@\spxentry{module}}

\section{Variograms}
\label{\detokenize{users_guide:variograms}}\label{\detokenize{users_guide:module-glomar_gridding.variogram}}
\sphinxAtStartPar
Varigram classes for construction of spatial covariance structure from distance
matrices.
\index{ExponentialVariogram (class in glomar\_gridding.variogram)@\spxentry{ExponentialVariogram}\spxextra{class in glomar\_gridding.variogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.ExponentialVariogram}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.variogram.}}\sphinxbfcode{\sphinxupquote{ExponentialVariogram}}}
{\sphinxparam{\DUrole{n}{psill}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nugget}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{effective\_range}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Exponential Model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{psill}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The variance of the variogram.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nugget}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{effective\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}})

\end{itemize}

\end{description}\end{quote}
\index{fit() (glomar\_gridding.variogram.ExponentialVariogram method)@\spxentry{fit()}\spxextra{glomar\_gridding.variogram.ExponentialVariogram method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.ExponentialVariogram.fit}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{fit}}}
{\sphinxparam{\DUrole{n}{distance\_matrix}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit the ExponentialVariogram model to a distance matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}} | \sphinxcode{\sphinxupquote{DataArray}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{GaussianVariogram (class in glomar\_gridding.variogram)@\spxentry{GaussianVariogram}\spxextra{class in glomar\_gridding.variogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.GaussianVariogram}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.variogram.}}\sphinxbfcode{\sphinxupquote{GaussianVariogram}}}
{\sphinxparam{\DUrole{n}{psill}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nugget}}\sphinxparamcomma \sphinxparam{\DUrole{n}{effective\_range}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Gaussian Model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{psill}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} The variance of the variogram.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nugget}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{effective\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}})

\end{itemize}

\end{description}\end{quote}
\index{fit() (glomar\_gridding.variogram.GaussianVariogram method)@\spxentry{fit()}\spxextra{glomar\_gridding.variogram.GaussianVariogram method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.GaussianVariogram.fit}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{fit}}}
{\sphinxparam{\DUrole{n}{distance\_matrix}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit the GaussianVariogram model to a distance matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}} | \sphinxcode{\sphinxupquote{DataArray}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LinearVariogram (class in glomar\_gridding.variogram)@\spxentry{LinearVariogram}\spxextra{class in glomar\_gridding.variogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.LinearVariogram}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.variogram.}}\sphinxbfcode{\sphinxupquote{LinearVariogram}}}
{\sphinxparam{\DUrole{n}{slope}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nugget}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Linear model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{slope}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nugget}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}})

\end{itemize}

\end{description}\end{quote}
\index{fit() (glomar\_gridding.variogram.LinearVariogram method)@\spxentry{fit()}\spxextra{glomar\_gridding.variogram.LinearVariogram method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.LinearVariogram.fit}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{fit}}}
{\sphinxparam{\DUrole{n}{distance\_matrix}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit the LinearVariogram model to a distance matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}} | \sphinxcode{\sphinxupquote{DataArray}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{MaternVariogram (class in glomar\_gridding.variogram)@\spxentry{MaternVariogram}\spxextra{class in glomar\_gridding.variogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.MaternVariogram}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.variogram.}}\sphinxbfcode{\sphinxupquote{MaternVariogram}}}
{\sphinxparam{\DUrole{n}{psill}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nugget}}\sphinxparamcomma \sphinxparam{\DUrole{n}{effective\_range}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{range}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nu}\DUrole{o}{=}\DUrole{default_value}{0.5}}\sphinxparamcomma \sphinxparam{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}sklearn\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Matern Models

\sphinxAtStartPar
Same args as the Variogram classes with additional nu, method parameters.

\sphinxAtStartPar
Sklearn:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {}
\sphinxAtStartPar
This is called “sklearn” because if d/range = 1.0 and nu=0.5, it gives
1/e correlation…

\item {}
\sphinxAtStartPar
This is NOT the same formulation as in GSTAT nor in papers about
non\sphinxhyphen{}stationary anistropic covariance models (aka Karspeck paper).

\item {}
\sphinxAtStartPar
It is perhaps the most intitutive (because of (1)) and is used in sklearn
GP and HadCRUT5 and other UKMO dataset.

\item {}
\sphinxAtStartPar
nu defaults to 0.5 (exponential; used in HADSST4 and our kriging).
HadCRUT5 uses 1.5.

\item {}
\sphinxAtStartPar
The “2” is inside the square root for middle and right.

\end{enumerate}

\sphinxAtStartPar
GeoStatic:

\sphinxAtStartPar
Similar to Sklearn MaternVariogram model but uses the range scaling in
gstat.
Note: there are no square root 2 or nu in middle and right

\sphinxAtStartPar
Yields the same answer to sklearn MaternVariogram if nu==0.5
but are otherwise different.

\sphinxAtStartPar
Karspeck:

\sphinxAtStartPar
Similar to Sklearn MaternVariogram model but uses the form in Karspeck paper
Note: Note the 2 is outside the square root for middle and right
e\sphinxhyphen{}folding distance is now at d/SQRT(2) for nu=0.5
\subsubsection*{References}

\sphinxAtStartPar
see chapter 4.2 of Rasmussen, C. E., \& Williams, C. K. I. (2005).
Gaussian Processes for Machine Learning. The MIT Press.
\sphinxurl{https://doi.org/10.7551/mitpress/3206.001.0001}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{psill}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Sill of the variogram where it will flatten out. Values in the variogram
will not exceed psill + nugget. This value is the variance.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nugget}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} The value of the independent variable at distance 0

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{effective\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Effective Range, this is the lag where 95\% of the sill are exceeded.
This is not the range parameter, which is defined as r/3 if nu \textless{} 0.5 or
nu \textgreater{} 10, otherwise r/2 (where r is the effective range). One of
effective\_range and range must be set.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{range}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} The range parameter. One of range and effective\_range must be set. If
range is not set, it will be computed from effective\_range.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nu}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Smoothing parameter, shapes to a smooth or rough variogram function

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{MaternModel}}) \textendash{}
\sphinxAtStartPar
One of “sklearn”, “gstat”, or “karspeck”:
\begin{itemize}
\item {}
\sphinxAtStartPar
sklearn: \sphinxurl{https://scikit-learn.org/stable/modules/generated/sklearn.gaussian\_process.kernels.Matern.html\#sklearn.gaussian\_process.kernels.Matern}

\item {}
\sphinxAtStartPar
gstat: \sphinxurl{https://scikit-gstat.readthedocs.io/en/latest/reference/models.html\#matern-model}

\item {}
\sphinxAtStartPar
karspeck: \sphinxurl{https://rmets.onlinelibrary.wiley.com/doi/10.1002/qj.900}

\end{itemize}


\end{itemize}

\end{description}\end{quote}
\index{fit() (glomar\_gridding.variogram.MaternVariogram method)@\spxentry{fit()}\spxextra{glomar\_gridding.variogram.MaternVariogram method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.MaternVariogram.fit}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{fit}}}
{\sphinxparam{\DUrole{n}{distance\_matrix}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit the MaternVariogram model to a distance matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}} | \sphinxcode{\sphinxupquote{DataArray}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PowerVariogram (class in glomar\_gridding.variogram)@\spxentry{PowerVariogram}\spxextra{class in glomar\_gridding.variogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.PowerVariogram}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.variogram.}}\sphinxbfcode{\sphinxupquote{PowerVariogram}}}
{\sphinxparam{\DUrole{n}{scale}}\sphinxparamcomma \sphinxparam{\DUrole{n}{exponent}}\sphinxparamcomma \sphinxparam{\DUrole{n}{nugget}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Power model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{exponent}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nugget}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}})

\end{itemize}

\end{description}\end{quote}
\index{fit() (glomar\_gridding.variogram.PowerVariogram method)@\spxentry{fit()}\spxextra{glomar\_gridding.variogram.PowerVariogram method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.PowerVariogram.fit}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{fit}}}
{\sphinxparam{\DUrole{n}{distance\_matrix}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit the PowerVariogram model to a distance matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}} | \sphinxcode{\sphinxupquote{DataArray}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Variogram (class in glomar\_gridding.variogram)@\spxentry{Variogram}\spxextra{class in glomar\_gridding.variogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.Variogram}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.variogram.}}\sphinxbfcode{\sphinxupquote{Variogram}}}
\pysigstopsignatures
\sphinxAtStartPar
Generic Variogram Class \sphinxhyphen{} defines the abstract class
\index{fit() (glomar\_gridding.variogram.Variogram method)@\spxentry{fit()}\spxextra{glomar\_gridding.variogram.Variogram method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.Variogram.fit}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{abstractmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{fit}}}
{\sphinxparam{\DUrole{n}{distance\_matrix}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit the Variogram model to a distance matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}} | \sphinxcode{\sphinxupquote{DataArray}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{variogram\_to\_covariance() (in module glomar\_gridding.variogram)@\spxentry{variogram\_to\_covariance()}\spxextra{in module glomar\_gridding.variogram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.variogram.variogram_to_covariance}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.variogram.}}\sphinxbfcode{\sphinxupquote{variogram\_to\_covariance}}}
{\sphinxparam{\DUrole{n}{variogram}}\sphinxparamcomma \sphinxparam{\DUrole{n}{variance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert a variogram matrix to a covariance matrix.
\begin{description}
\sphinxlineitem{This is given by:}
\sphinxAtStartPar
covariance = variance \sphinxhyphen{} variogram

\end{description}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{variogram}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} The variogram matrix, output of Variogram.fit.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{variance}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The variance

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{cov} \textendash{} The covariance matrix

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray | xarray.DataArray

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.kriging@\spxentry{glomar\_gridding.kriging}}\index{glomar\_gridding.kriging@\spxentry{glomar\_gridding.kriging}!module@\spxentry{module}}

\section{Kriging}
\label{\detokenize{users_guide:kriging}}\label{\detokenize{users_guide:module-glomar_gridding.kriging}}
\sphinxAtStartPar
Functions for performing Kriging.

\sphinxAtStartPar
Interpolation using a Gaussian Process. Available methods are Simple and
Ordinary Kriging.
\index{Kriging (class in glomar\_gridding.kriging)@\spxentry{Kriging}\spxextra{class in glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.Kriging}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{Kriging}}}
{\sphinxparam{\DUrole{n}{covariance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Class for Kriging.

\sphinxAtStartPar
Do not use this class, use SimpleKriging or OrdinaryKriging classes.
\index{constraint\_mask() (glomar\_gridding.kriging.Kriging method)@\spxentry{constraint\_mask()}\spxextra{glomar\_gridding.kriging.Kriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.Kriging.constraint_mask}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{abstractmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{constraint\_mask}}}
{\sphinxparam{\DUrole{n}{idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the observational constraint mask (A14 in Morice et al. (2021) \sphinxhyphen{}
10.1029/2019JD032361) to determine if a grid point should be
masked/weights modified by how far it is to its near observed point

\sphinxAtStartPar
Note: typo in Section A4 in Morice et al 2021 (confired by authors).

\sphinxAtStartPar
Equation to use is A14 is incorrect. Easily noticeable because
dimensionally incorrect is wrong, but the correct answer is easy to
figure out.

\sphinxAtStartPar
Correct Equation (extra matrix inverse for \(K_{obs} + E\)):
\begin{equation*}
\begin{split}1 - diag\\(K - K_{cross}^T @ (K + E)^{-1} @ K_{cross}\\)  / diag(K)
< alpha\end{split}
\end{equation*}
\sphinxAtStartPar
This can be re\sphinxhyphen{}written as:
\begin{equation*}
\begin{split}diag\\(K_{cross}^T @ (K_{obs} + E)^{-1} @ K_{cross}\\) / diag(K)
< alpha\end{split}
\end{equation*}
\sphinxAtStartPar
alpha is chosen to be 0.25 in the UKMO paper

\sphinxAtStartPar
Written by S. Chan, modified by J. Siddons.

\sphinxAtStartPar
This requires that the \sphinxtitleref{kriging\_weights} attribute is set.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged. Used to compute the Kriging weights.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{constraint\_mask} \textendash{} Constraint mask values, the left\sphinxhyphen{}hand\sphinxhyphen{}side of equation A14 from
Morice et al. (2021). This is a vector of length \sphinxtitleref{k\_obs.size{[}0{]}}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Morice et al. (2021) : \sphinxurl{https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019JD032361}

\end{fulllineitems}

\index{get\_kriging\_weights() (glomar\_gridding.kriging.Kriging method)@\spxentry{get\_kriging\_weights()}\spxextra{glomar\_gridding.kriging.Kriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.Kriging.get_kriging_weights}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{abstractmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{get\_kriging\_weights}}}
{\sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the Kriging weights from the flattened grid indices where
there is an observation. Optionally add an error covariance to the
covariance between observation grid points.

\sphinxAtStartPar
The Kriging weights are calculated as:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, and \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points).

\sphinxAtStartPar
Sets the \sphinxtitleref{kriging\_weights} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally add error covariance values to the covariance between
observation grid points.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_uncertainty() (glomar\_gridding.kriging.Kriging method)@\spxentry{get\_uncertainty()}\spxextra{glomar\_gridding.kriging.Kriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.Kriging.get_uncertainty}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{abstractmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{get\_uncertainty}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the kriging uncertainty. This requires the attribute
\sphinxtitleref{kriging\_weights} to be computed.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{uncert} \textendash{} The Kriging uncertainty.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{kriging\_weights\_from\_inverse() (glomar\_gridding.kriging.Kriging method)@\spxentry{kriging\_weights\_from\_inverse()}\spxextra{glomar\_gridding.kriging.Kriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.Kriging.kriging_weights_from_inverse}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{abstractmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{kriging\_weights\_from\_inverse}}}
{\sphinxparam{\DUrole{n}{inv}}\sphinxparamcomma \sphinxparam{\DUrole{n}{idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the Kriging weights from the flattened grid indices where
there is an observation, using a pre\sphinxhyphen{}computed inverse of the covariance
between grid\sphinxhyphen{}points with observations.

\sphinxAtStartPar
The Kriging weights are calculated as:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, and \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points).

\sphinxAtStartPar
Sets the \sphinxtitleref{kriging\_weights} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The pre\sphinxhyphen{}computed inverse of the covariance between grid\sphinxhyphen{}points with
observations. \((K_{obs} + E)^{-1}\)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_kriging\_weights() (glomar\_gridding.kriging.Kriging method)@\spxentry{set\_kriging\_weights()}\spxextra{glomar\_gridding.kriging.Kriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.Kriging.set_kriging_weights}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{set\_kriging\_weights}}}
{\sphinxparam{\DUrole{n}{kriging\_weights}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Set Kriging Weights.

\sphinxAtStartPar
Sets the \sphinxtitleref{kriging\_weights} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kriging\_weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The pre\sphinxhyphen{}computed kriging\_weights to use.

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (glomar\_gridding.kriging.Kriging method)@\spxentry{solve()}\spxextra{glomar\_gridding.kriging.Kriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.Kriging.solve}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{abstractmethod}\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{solve}}}
{\sphinxparam{\DUrole{n}{grid\_obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Solves the Kriging problem. Computes the Kriging weights if the
\sphinxtitleref{kriging\_weights} attribute is not already set. The solution to Kriging
is:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross} \\times y\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points), and \(y\) are the observation values.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The observation values. If there are multiple observations in any
grid box then these values need to be averaged into one value per
grid box.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged. Used to compute the Kriging weights.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally add error covariance values to the covariance between
observation grid points. Used to compute Kriging weights.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The solution to the Kriging problem (as a Vector, this may need to
be re\sphinxhyphen{}shaped appropriately as a post\sphinxhyphen{}processing step).

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{OrdinaryKriging (class in glomar\_gridding.kriging)@\spxentry{OrdinaryKriging}\spxextra{class in glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.OrdinaryKriging}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{OrdinaryKriging}}}
{\sphinxparam{\DUrole{n}{covariance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Class for OrdinaryKriging.

\sphinxAtStartPar
The equation for ordinary Kriging is:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross} \\times y\end{split}
\end{equation*}
\sphinxAtStartPar
with a constant but unknown mean.

\sphinxAtStartPar
In this case, the \(K_{obs}\), \(K_{cross}\) and \(y\) values
are extended with a Lagrange multiplier term, ensuring that the Kriging
weights are constrained to sum to 1.

\sphinxAtStartPar
The matrix \(K_{obs}\) is extended by one row and one column, each
containing the value 1, except at the diagonal point, which is 0. The
\(K_{cross}\) matrix is extended by an extra row containing values of 1.
Finally, the grid observations \(y\) is extended by a single value of 0
at the end of the vector.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{covariance}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The spatial covariance matrix. This can be a pre\sphinxhyphen{}computed matrix loaded
into the environment, or computed from a Variogram class or using
Ellipse methods.

\end{description}\end{quote}
\index{constraint\_mask() (glomar\_gridding.kriging.OrdinaryKriging method)@\spxentry{constraint\_mask()}\spxextra{glomar\_gridding.kriging.OrdinaryKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.OrdinaryKriging.constraint_mask}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{constraint\_mask}}}
{\sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{simple\_kriging\_weights}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the observational constraint mask (A14 in Morice et al. (2021) \sphinxhyphen{}
10.1029/2019JD032361) to determine if a grid point should be
masked/weights modified by how far it is to its near observed point

\sphinxAtStartPar
Note: typo in Section A4 in Morice et al 2021 (confired by authors).

\sphinxAtStartPar
Equation to use is A14 is incorrect. Easily noticeable because
dimensionally incorrect is wrong, but the correct answer is easy to
figure out.

\sphinxAtStartPar
Correct Equation (extra matrix inverse for \(K_{obs} + E\)):
\begin{equation*}
\begin{split}1 - diag\\(K - K_{cross}^T @ (K + E)^{-1} @ K_{cross}\\)  / diag(K)
< alpha\end{split}
\end{equation*}
\sphinxAtStartPar
This can be re\sphinxhyphen{}written as:
\begin{equation*}
\begin{split}diag\\(K_{cross}^T @ (K_{obs} + E)^{-1} @ K_{cross}\\) / diag(K)
< alpha\end{split}
\end{equation*}
\sphinxAtStartPar
alpha is chosen to be 0.25 in the UKMO paper

\sphinxAtStartPar
Written by S. Chan, modified by J. Siddons.

\sphinxAtStartPar
This requires the Kriging weights from simple Kriging. If these are
not provided as an input, then they are calculated.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged. Used to compute the Kriging weights.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{simple\_kriging\_weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} The Kriging weights for the equivalent simple Kriging system.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} The error covariance matrix. Used to compute the simple Kriging
weights if not provided. Can be excluded if not Kriging with an
error covariance.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{constraint\_mask} \textendash{} Constraint mask values, the left\sphinxhyphen{}hand\sphinxhyphen{}side of equation A14 from
Morice et al. (2021). This is a vector of length \sphinxtitleref{k\_obs.size{[}0{]}}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Morice et al. (2021) : \sphinxurl{https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019JD032361}

\end{fulllineitems}

\index{extended\_inverse() (glomar\_gridding.kriging.OrdinaryKriging method)@\spxentry{extended\_inverse()}\spxextra{glomar\_gridding.kriging.OrdinaryKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.OrdinaryKriging.extended_inverse}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{extended\_inverse}}}
{\sphinxparam{\DUrole{n}{simple\_inv}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the inverse of a covariance matrix \(S = K_{obs} + E\), and
use that to compute the inverse of the extended version of the
covariance matrix with Lagrange multipliers, used by Ordinary Kriging.

\sphinxAtStartPar
This is useful when one needs to perform BOTH simple and ordinary
Kriging, or when one wishes to compute the constraint mask for
ordinary Kriging which requires the Kriging weights for the equivalent
simple Kriging problem.

\sphinxAtStartPar
The extended form of S is given by

\begin{DUlineblock}{0em}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1 |
\end{DUlineblock}
\item[] S   1 |
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1 |
\end{DUlineblock}
\end{DUlineblock}
\item[] 1 1 1 0 |
\end{DUlineblock}

\sphinxAtStartPar
This approach follows Guttman 1946 10.1214/aoms/1177730946
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{simple\_inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.matrix}}) \textendash{} Inverse of the covariance between observation grid\sphinxhyphen{}points

\sphinxlineitem{Returns}
\sphinxAtStartPar
Inverse of the extended covariance matrix between observation
grid\sphinxhyphen{}points including the Lagrange multiplier factors.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_kriging\_weights() (glomar\_gridding.kriging.OrdinaryKriging method)@\spxentry{get\_kriging\_weights()}\spxextra{glomar\_gridding.kriging.OrdinaryKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.OrdinaryKriging.get_kriging_weights}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_kriging\_weights}}}
{\sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the Kriging weights from the flattened grid indices where
there is an observation. Optionally add an error covariance to the
covariance between observation grid points.

\sphinxAtStartPar
The Kriging weights are calculated as:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, and \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points).

\sphinxAtStartPar
In this case, the \(K_{obs}\), \(K_{cross}\) and are extended
with a Lagrange multiplier term, ensuring that the Kriging weights are
constrained to sum to 1.

\sphinxAtStartPar
The matrix \(K_{obs}\) is extended by one row and one column, each
containing the value 1, except at the diagonal point, which is 0. The
\(K_{cross}\) matrix is extended by an extra row containing values
of 1.

\sphinxAtStartPar
Sets the \sphinxtitleref{kriging\_weights} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally add error covariance values to the covariance between
observation grid points.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_uncertainty() (glomar\_gridding.kriging.OrdinaryKriging method)@\spxentry{get\_uncertainty()}\spxextra{glomar\_gridding.kriging.OrdinaryKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.OrdinaryKriging.get_uncertainty}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_uncertainty}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the kriging uncertainty. This requires the attribute
\sphinxtitleref{kriging\_weights} to be computed.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{uncert} \textendash{} The Kriging uncertainty.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{kriging\_weights\_from\_inverse() (glomar\_gridding.kriging.OrdinaryKriging method)@\spxentry{kriging\_weights\_from\_inverse()}\spxextra{glomar\_gridding.kriging.OrdinaryKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.OrdinaryKriging.kriging_weights_from_inverse}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{kriging\_weights\_from\_inverse}}}
{\sphinxparam{\DUrole{n}{inv}}\sphinxparamcomma \sphinxparam{\DUrole{n}{idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the Kriging weights from the flattened grid indices where
there is an observation, using a pre\sphinxhyphen{}computed inverse of the covariance
between grid\sphinxhyphen{}points with observations.

\sphinxAtStartPar
The Kriging weights are calculated as:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, and \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points).

\sphinxAtStartPar
In this case, the inverse matrix must be computed from the covariance
between observation grid\sphinxhyphen{}points with the Lagrange multiplier applied.

\sphinxAtStartPar
This method is appropriate if one wants to compute the constraint mask
which requires simple Kriging weights, which can be computed from the
unextended covariance inverse. The extended inverse can then be
calculated from that inverse.

\sphinxAtStartPar
Sets the \sphinxtitleref{kriging\_weights} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The pre\sphinxhyphen{}computed inverse of the covariance between grid\sphinxhyphen{}points with
observations. \((K_{obs} + E)^{-1}\)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (glomar\_gridding.kriging.OrdinaryKriging method)@\spxentry{solve()}\spxextra{glomar\_gridding.kriging.OrdinaryKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.OrdinaryKriging.solve}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{solve}}}
{\sphinxparam{\DUrole{n}{grid\_obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Solves the simple Kriging problem. Computes the Kriging weights if the
\sphinxtitleref{kriging\_weights} attribute is not already set. The solution to Kriging
is:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross} \\times y\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points), and \(y\) are the observation values.

\sphinxAtStartPar
In this case, the \(K_{obs}\), \(K_{cross}\) and are extended
with a Lagrange multiplier term, ensuring that the Kriging weights are
constrained to sum to 1.

\sphinxAtStartPar
The matrix \(K_{obs}\) is extended by one row and one column, each
containing the value 1, except at the diagonal point, which is 0. The
\(K_{cross}\) matrix is extended by an extra row containing values
of 1.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The observation values. If there are multiple observations in any
grid box then these values need to be averaged into one value per
grid box.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged. Used to compute the Kriging weights.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally add error covariance values to the covariance between
observation grid points. Used to compute Kriging weights.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The solution to the ordinary Kriging problem (as a Vector, this may
need to be re\sphinxhyphen{}shaped appropriately as a post\sphinxhyphen{}processing step).

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SimpleKriging (class in glomar\_gridding.kriging)@\spxentry{SimpleKriging}\spxextra{class in glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.SimpleKriging}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{SimpleKriging}}}
{\sphinxparam{\DUrole{n}{covariance}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Class for SimpleKriging.

\sphinxAtStartPar
The equation for simple Kriging is:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross} \\times y + \\mu\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\\mu\) is a constant known mean, typically this is 0.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{covariance}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The spatial covariance matrix. This can be a pre\sphinxhyphen{}computed matrix loaded
into the environment, or computed from a Variogram class or using
Ellipse methods.

\end{description}\end{quote}
\index{constraint\_mask() (glomar\_gridding.kriging.SimpleKriging method)@\spxentry{constraint\_mask()}\spxextra{glomar\_gridding.kriging.SimpleKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.SimpleKriging.constraint_mask}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{constraint\_mask}}}
{\sphinxparam{\DUrole{n}{idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the observational constraint mask (A14 in Morice et al. (2021) \sphinxhyphen{}
10.1029/2019JD032361) to determine if a grid point should be
masked/weights modified by how far it is to its near observed point

\sphinxAtStartPar
Note: typo in Section A4 in Morice et al 2021 (confired by authors).

\sphinxAtStartPar
Equation to use is A14 is incorrect. Easily noticeable because
dimensionally incorrect is wrong, but the correct answer is easy to
figure out.

\sphinxAtStartPar
Correct Equation (extra matrix inverse for \(K_{obs} + E\)):
\begin{equation*}
\begin{split}1 - diag\\(K - K_{cross}^T @ (K + E)^{-1} @ K_{cross}\\)  / diag(K)
< alpha\end{split}
\end{equation*}
\sphinxAtStartPar
This can be re\sphinxhyphen{}written as:
\begin{equation*}
\begin{split}diag\\(K_{cross}^T @ (K_{obs} + E)^{-1} @ K_{cross}\\) / diag(K)
< alpha\end{split}
\end{equation*}
\sphinxAtStartPar
alpha is chosen to be 0.25 in the UKMO paper

\sphinxAtStartPar
Written by S. Chan, modified by J. Siddons.

\sphinxAtStartPar
This requires that the \sphinxtitleref{kriging\_weights} attribute is set.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged. Used to compute the Kriging weights.

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{constraint\_mask} \textendash{} Constraint mask values, the left\sphinxhyphen{}hand\sphinxhyphen{}side of equation A14 from
Morice et al. (2021). This is a vector of length \sphinxtitleref{k\_obs.size{[}0{]}}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Morice et al. (2021) : \sphinxurl{https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019JD032361}

\end{fulllineitems}

\index{get\_kriging\_weights() (glomar\_gridding.kriging.SimpleKriging method)@\spxentry{get\_kriging\_weights()}\spxextra{glomar\_gridding.kriging.SimpleKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.SimpleKriging.get_kriging_weights}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_kriging\_weights}}}
{\sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the Kriging weights from the flattened grid indices where
there is an observation. Optionally add an error covariance to the
covariance between observation grid points.

\sphinxAtStartPar
The Kriging weights are calculated as:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, and \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points).

\sphinxAtStartPar
Sets the \sphinxtitleref{kriging\_weights} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally add error covariance values to the covariance between
observation grid points.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_uncertainty() (glomar\_gridding.kriging.SimpleKriging method)@\spxentry{get\_uncertainty()}\spxextra{glomar\_gridding.kriging.SimpleKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.SimpleKriging.get_uncertainty}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{get\_uncertainty}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the kriging uncertainty. This requires the attribute
\sphinxtitleref{kriging\_weights} to be computed.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{uncert} \textendash{} The Kriging uncertainty.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{kriging\_weights\_from\_inverse() (glomar\_gridding.kriging.SimpleKriging method)@\spxentry{kriging\_weights\_from\_inverse()}\spxextra{glomar\_gridding.kriging.SimpleKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.SimpleKriging.kriging_weights_from_inverse}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{kriging\_weights\_from\_inverse}}}
{\sphinxparam{\DUrole{n}{inv}}\sphinxparamcomma \sphinxparam{\DUrole{n}{idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the Kriging weights from the flattened grid indices where
there is an observation, using a pre\sphinxhyphen{}computed inverse of the covariance
between grid\sphinxhyphen{}points with observations.

\sphinxAtStartPar
The Kriging weights are calculated as:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, and \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points).

\sphinxAtStartPar
Sets the \sphinxtitleref{kriging\_weights} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inv}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The pre\sphinxhyphen{}computed inverse of the covariance between grid\sphinxhyphen{}points with
observations. \((K_{obs} + E)^{-1}\)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (glomar\_gridding.kriging.SimpleKriging method)@\spxentry{solve()}\spxextra{glomar\_gridding.kriging.SimpleKriging method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.SimpleKriging.solve}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{solve}}}
{\sphinxparam{\DUrole{n}{grid\_obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mean}\DUrole{o}{=}\DUrole{default_value}{0.0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Solves the simple Kriging problem. Computes the Kriging weights if the
\sphinxtitleref{kriging\_weights} attribute is not already set. The solution to Kriging
is:
\begin{equation*}
\begin{split}(K_{obs} + E)^{-1} \\times K_{cross} \\times y\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(K_{obs}\) is the spatial covariance between grid\sphinxhyphen{}points
with observations, \(E\) is the error covariance between grid\sphinxhyphen{}points
with observations, \(K_{cross}\) is the covariance between
grid\sphinxhyphen{}points with observations and all grid\sphinxhyphen{}points (including observation
grid\sphinxhyphen{}points), and \(y\) are the observation values.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The observation values. If there are multiple observations in any
grid box then these values need to be averaged into one value per
grid box.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The 1d indices of observation grid points. These values should be
between 0 and (N * M) \sphinxhyphen{} 1 where N, M are the number of longitudes
and latitudes respectively. Note that these values should also be
computed using “C” ordering in numpy reshaping. They can be
computed from a grid using glomar\_gridding.grid.map\_to\_grid. Each
value should only appear once. Points that contain more than 1
observation should be averaged. Used to compute the Kriging weights.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally add error covariance values to the covariance between
observation grid points. Used to compute Kriging weights.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Constant, known, mean value of the system. Defaults to 0.0.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The solution to the simple Kriging problem (as a Vector, this may
need to be re\sphinxhyphen{}shaped appropriately as a post\sphinxhyphen{}processing step).

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{constraint\_mask() (in module glomar\_gridding.kriging)@\spxentry{constraint\_mask()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.constraint_mask}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{constraint\_mask}}}
{\sphinxparam{\DUrole{n}{obs\_obs\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_grid\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{interp\_cov}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the observational constraint mask (A14 in Morice et al. (2021) \sphinxhyphen{}
10.1029/2019JD032361) to determine if a grid point should be masked/weights
modified by how far it is to its near observed point

\sphinxAtStartPar
Note: typo in Section A4 in Morice et al 2021 (confired by authors).

\sphinxAtStartPar
Equation to use is A14 is incorrect. Easily noticeable because dimensionally
incorrect is wrong, but the correct answer is easy to figure out.

\sphinxAtStartPar
Correct Equation (extra matrix inverse for K+R):
1 \sphinxhyphen{} diag( K(X*,X*) \sphinxhyphen{} k*\textasciicircum{}T @ (K+R)\textasciicircum{}\{\sphinxhyphen{}1\} @ k* )  / diag( K(X*,X*) )  \textless{} alpha

\sphinxAtStartPar
This can be re\sphinxhyphen{}written as:
diag(k*\textasciicircum{}T @ (K+R)\textasciicircum{}\{\sphinxhyphen{}1\} @ k*) / diag(K(X*, X*)) \textless{} alpha

\sphinxAtStartPar
alpha is chosen to be 0.25 in the UKMO paper

\sphinxAtStartPar
Written by S. Chan, modified by J. Siddons.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obs\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Covariance between all measured grid points plus the covariance due to
measurements (i.e. measurement noise, bias noise, and sampling noise).
Can include error covariance terms, if these are being used. This is
\sphinxtitleref{K + R} in the above equation.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_grid\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Covariance between the all (predicted) grid points and measured points.
Does not contain error covarance. This is \sphinxtitleref{k*} in the above equation.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{interp\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Interpolation covariance of all output grid points (each point in time
and all points against each other). This is \sphinxtitleref{K(X*, X*)} in the above
equation.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{constraint\_mask} \textendash{} Constraint mask values, the left\sphinxhyphen{}hand\sphinxhyphen{}side of equation A14 from Morice
et al. (2021). This is a vector of length \sphinxtitleref{k\_obs.size{[}0{]}}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
Morice et al. (2021) : \sphinxurl{https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019JD032361}

\end{fulllineitems}

\index{get\_spatial\_mean() (in module glomar\_gridding.kriging)@\spxentry{get\_spatial\_mean()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.get_spatial_mean}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{get\_spatial\_mean}}}
{\sphinxparam{\DUrole{n}{grid\_obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{covx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the spatial mean accounting for auto\sphinxhyphen{}correlation.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Vector containing observations

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{covx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Observation covariance matrix

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{spatial\_mean} \textendash{} The spatial mean defined as (1\textasciicircum{}T x C\textasciicircum{}\{\sphinxhyphen{}1\} x 1)\textasciicircum{}\{\sphinxhyphen{}1\} * (1\textasciicircum{}T x C\textasciicircum{}\{\sphinxhyphen{}1\} x z)

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}
\subsubsection*{References}

\sphinxAtStartPar
\sphinxurl{https://www.css.cornell.edu/faculty/dgr2/\_static/files/distance\_ed\_geostats/ov5.pdf}

\end{fulllineitems}

\index{get\_unmasked\_obs\_indices() (in module glomar\_gridding.kriging)@\spxentry{get\_unmasked\_obs\_indices()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.get_unmasked_obs_indices}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{get\_unmasked\_obs\_indices}}}
{\sphinxparam{\DUrole{n}{unmask\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{unique\_obs\_idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get grid indices with observations from un\sphinxhyphen{}masked grid\sphinxhyphen{}box indices and
unique grid\sphinxhyphen{}box indices with observations.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{unmask\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} List of all unmasked grid\sphinxhyphen{}box indices.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{unique\_obs\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Indices of grid\sphinxhyphen{}boxes with observations.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{obs\_idx} \textendash{} Subset of grid\sphinxhyphen{}box indices containing observations that are unmasked.

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray{[}int{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{kriging() (in module glomar\_gridding.kriging)@\spxentry{kriging()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.kriging}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{kriging}}}
{\sphinxparam{\DUrole{n}{obs\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{weights}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{interp\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{remove\_obs\_mean}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_bias}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}simple\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Perform Kriging using a chosen method.

\sphinxAtStartPar
Get array of krigged observations and anomalies for all grid points in the
domain.

\sphinxAtStartPar
This function is deprecated in favour of SimpleKriging and OrdinaryKriging
classes. It will be removed in version 1.0.0.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Grid indices with observations. It is expected that this should be an
ordering that lines up with the 1st dimension of weights. If
\sphinxtitleref{observations.dist\_weights} or \sphinxtitleref{observations.get\_weights} was used to
get the weights then this is the ordering of
\sphinxtitleref{sorted(df{[}“gridbox”{]}.unique())}, which is a sorting on lat and lon

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Weight matrix (inverse of counts of observations).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} All point observations/measurements for the chosen date.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{interp\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} interpolation covariance of all output grid points (each point in time
and all points against each other).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Measurement/Error covariance matrix.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{remove\_obs\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Should the mean or median from grib\_obs be removed and added back onto
grib\_obs?
0 = No (default action)
1 = the mean is removed
2 = the median is removed
3 = the spatial meam os removed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_bias}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Bias of all measurement points for a chosen date (corresponds to x\_obs).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{KrigMethod}}) \textendash{} The kriging method to use to fill in the output grid. One of “simple”
or “ordinary”.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{z\_obs} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Full set of values for the whole domain derived from the observation
points using the chosen kriging method.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{dz} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Uncertainty associated with the chosen kriging method.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{kriging\_ordinary() (in module glomar\_gridding.kriging)@\spxentry{kriging\_ordinary()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.kriging_ordinary}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{kriging\_ordinary}}}
{\sphinxparam{\DUrole{n}{obs\_obs\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_grid\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid\_obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{interp\_cov}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Perform Ordinary Kriging with unknown but constant mean.

\sphinxAtStartPar
This function is deprecated in favour of OrdinaryKriging class. It will be
removed in version 1.0.0.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obs\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Covariance between all measured grid points plus the covariance due to
measurements (i.e. measurement noise, bias noise, and sampling noise).
Can include error covariance terms, if these are being used.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_grid\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Covariance between the all (predicted) grid points and measured points.
Does not contain error covarance.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Gridded measurements (all measurement points averaged onto the output
gridboxes).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{interp\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Interpolation covariance of all output grid points (each point in time
and all points against each other).

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{z\_obs} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Full set of values for the whole domain derived from the observation
points using ordinary kriging.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{dz} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Uncertainty associated with the ordinary kriging.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{kriging\_simple() (in module glomar\_gridding.kriging)@\spxentry{kriging\_simple()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.kriging_simple}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{kriging\_simple}}}
{\sphinxparam{\DUrole{n}{obs\_obs\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_grid\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid\_obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{interp\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mean}\DUrole{o}{=}\DUrole{default_value}{0.0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Perform Simple Kriging assuming a constant known mean.

\sphinxAtStartPar
This function is deprecated in favour of SimpleKriging class. It will be
removed in version 1.0.0.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_obs\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Covariance between all measured grid points plus the
covariance due to measurements (i.e. measurement noise, bias noise, and
sampling noise). Can include error covariance terms.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_grid\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Covariance between the all (predicted) grid points and measured points.
Does not contain error covarance.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Gridded measurements (all measurement points averaged onto the output
gridboxes).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{interp\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} interpolation covariance of all output grid points (each point in time
and all points against each other).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The constant mean of the output field.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{z\_obs} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Full set of values for the whole domain derived from the observation
points using simple kriging.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{dz} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Uncertainty associated with the simple kriging.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{prep\_obs\_for\_kriging() (in module glomar\_gridding.kriging)@\spxentry{prep\_obs\_for\_kriging()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.prep_obs_for_kriging}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{prep\_obs\_for\_kriging}}}
{\sphinxparam{\DUrole{n}{unmask\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{unique\_obs\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{weights}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{remove\_obs\_mean}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_bias}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Prep masked observations for Kriging. Combines observations in the same
grid box to a single averaged observation using a weighted average.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{unmask\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Indices of all un\sphinxhyphen{}masked points for chosen date.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{unique\_obs\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Unique indices of all measurement points for a chosen date,
representative of the indices of gridboxes, which have =\textgreater{} 1 measurement.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Weight matrix (inverse of counts of observations).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} All point observations/measurements for the chosen date.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{remove\_obs\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Should the mean or median from obs be removed and added back onto obs?
0 = No (default action)
1 = the mean is removed
2 = the median is removed
3 = the spatial meam os removed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_bias}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Bias of all measurement points for a chosen date (corresponds to x\_obs).

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{obs\_idx} (\sphinxstyleemphasis{numpy.ndarray{[}int{]}}) \textendash{} Subset of grid\sphinxhyphen{}box indices containing observations that are unmasked.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{grid\_obs} (\sphinxstyleemphasis{numpy.ndarray{[}float{]}}) \textendash{} Unmasked and combined observations

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{unmasked\_kriging() (in module glomar\_gridding.kriging)@\spxentry{unmasked\_kriging()}\spxextra{in module glomar\_gridding.kriging}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.kriging.unmasked_kriging}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.kriging.}}\sphinxbfcode{\sphinxupquote{unmasked\_kriging}}}
{\sphinxparam{\DUrole{n}{unmask\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{unique\_obs\_idx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{weights}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{interp\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{error\_cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{remove\_obs\_mean}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_bias}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}simple\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Perform Kriging on a masked grid using a chosen method.

\sphinxAtStartPar
Get array of krigged observations and anomalies for all grid points in the
domain.

\sphinxAtStartPar
This function is deprecated in favour of SimpleKriging and OrdinaryKriging
classes. It will be removed in version 1.0.0.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{unmask\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Indices of all un\sphinxhyphen{}masked points for chosen date.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{unique\_obs\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Unique indices of all measurement points for a chosen date,
representative of the indices of gridboxes, which have =\textgreater{} 1 measurement.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Weight matrix (inverse of counts of observations).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} All point observations/measurements for the chosen date.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{interp\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Interpolation covariance of all output grid points (each point in time
and all points
against each other).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error\_cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Measurement/Error covariance matrix.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{remove\_obs\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Should the mean or median from obs be removed and added back onto obs?
0 = No (default action)
1 = the mean is removed
2 = the median is removed
3 = the spatial meam os removed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_bias}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Bias of all measurement points for a chosen date (corresponds to x\_obs).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{KrigMethod}}) \textendash{} The kriging method to use to fill in the output grid. One of “simple”
or “ordinary”.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{z\_obs} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Full set of values for the whole domain derived from the observation
points using the chosen kriging method.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{dz} (\sphinxstyleemphasis{np.ndarray{[}float{]}}) \textendash{} Uncertainty associated with the chosen kriging method.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.climatology@\spxentry{glomar\_gridding.climatology}}\index{glomar\_gridding.climatology@\spxentry{glomar\_gridding.climatology}!module@\spxentry{module}}

\section{Climatology}
\label{\detokenize{users_guide:climatology}}\label{\detokenize{users_guide:module-glomar_gridding.climatology}}
\sphinxAtStartPar
Functions for mapping climatologies and computing anomalies
\index{join\_climatology\_by\_doy() (in module glomar\_gridding.climatology)@\spxentry{join\_climatology\_by\_doy()}\spxextra{in module glomar\_gridding.climatology}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.climatology.join_climatology_by_doy}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.climatology.}}\sphinxbfcode{\sphinxupquote{join\_climatology\_by\_doy}}}
{\sphinxparam{\DUrole{n}{obs\_df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{climatology\_365}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lat\_col}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}lat\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lon\_col}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}lon\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{date\_col}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}date\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{var\_col}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}sst\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{clim\_lat}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}latitude\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{clim\_lon}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}longitude\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{clim\_doy}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}doy\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{clim\_var}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}climatology\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{temp\_from\_kelvin}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Merge a climatology from an xarray.DataArray into a polars.DataFrame using
the day of year value and position.

\sphinxAtStartPar
This function accounts for leap years by taking the average of the
climatology values for 28th Feb and 1st March for observations that were
made on the 29th of Feb.

\sphinxAtStartPar
The climatology is merged into the DataFrame and anomaly values are
computed.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} Observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{climatology\_365}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} DataArray containing daily climatology values (for 365 days).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lat\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the latitude column in the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lon\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the longitude column in the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{date\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the datetime column in the observational DataFrame. Day of year
values are computed from this value.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the variable column in the observational DataFrame. The merged
climatology names will have this name prefixed to “\_climatology”, the
anomaly values will have this name prefixed to “\_anomaly”.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clim\_lat}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the latitude coordinate in the climatology DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clim\_lon}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the longitude coordinate in the climatology DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clim\_doy}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the day of year coordinate in the climatology DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clim\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the climatology variable in the climatology DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{temp\_from\_kelvin}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Optionally adjust the climatology from Kelvin to Celsius if the variable
is a temperature.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{obs\_df} \textendash{} With the climatology merged and anomaly computed. The new columns are
“\_climatology” and “\_anomaly” prefixed by the \sphinxtitleref{var\_col} value
respectively.

\sphinxlineitem{Return type}
\sphinxAtStartPar
polars.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_climatology() (in module glomar\_gridding.climatology)@\spxentry{read\_climatology()}\spxextra{in module glomar\_gridding.climatology}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.climatology.read_climatology}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.climatology.}}\sphinxbfcode{\sphinxupquote{read\_climatology}}}
{\sphinxparam{\DUrole{n}{clim\_path}}\sphinxparamcomma \sphinxparam{\DUrole{n}{min\_lat}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}90}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_lat}\DUrole{o}{=}\DUrole{default_value}{90}}\sphinxparamcomma \sphinxparam{\DUrole{n}{min\_lon}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}180}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_lon}\DUrole{o}{=}\DUrole{default_value}{180}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lat\_var}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}lat\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lon\_var}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}lon\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Load a climatology dataset from a netCDF file.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clim\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the climatology file. Can contain format blocks to be replaced
by the values passed to kwargs.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_lat}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minimum latitude to load.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_lat}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Maximum latitude to load.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_lon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minimum longitude to load.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_lon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Maximum longitude to load.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lat\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the latitude variable.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lon\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the longitude variable.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Replacement values for the climatology path.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{clim\_ds} \textendash{} Containing the climatology bounded by the min/max arguments provided.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.Dataset

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.mask@\spxentry{glomar\_gridding.mask}}\index{glomar\_gridding.mask@\spxentry{glomar\_gridding.mask}!module@\spxentry{module}}

\section{Masking}
\label{\detokenize{users_guide:masking}}\label{\detokenize{users_guide:module-glomar_gridding.mask}}
\sphinxAtStartPar
Functions for applying masks to grids and DataFrames
\index{get\_mask\_idx() (in module glomar\_gridding.mask)@\spxentry{get\_mask\_idx()}\spxextra{in module glomar\_gridding.mask}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.mask.get_mask_idx}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.mask.}}\sphinxbfcode{\sphinxupquote{get\_mask\_idx}}}
{\sphinxparam{\DUrole{n}{mask}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_val}\DUrole{o}{=}\DUrole{default_value}{nan}}\sphinxparamcomma \sphinxparam{\DUrole{n}{masked}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get the 1d indices of masked values from a mask array.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} The mask array, containing values indicated a masked value.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_val}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} The value that indicates the position should be masked.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{masked}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Return indices where values in the mask array equal this value. If set
to False it will return indices where values are not equal to the mask
value. Can be used to get unmasked indices if this value is set to
False.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
An array of integers indicating the indices which are masked.

\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_array() (in module glomar\_gridding.mask)@\spxentry{mask\_array()}\spxextra{in module glomar\_gridding.mask}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.mask.mask_array}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.mask.}}\sphinxbfcode{\sphinxupquote{mask\_array}}}
{\sphinxparam{\DUrole{n}{grid}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask}}\sphinxparamcomma \sphinxparam{\DUrole{n}{varname}}\sphinxparamcomma \sphinxparam{\DUrole{n}{masked\_value}\DUrole{o}{=}\DUrole{default_value}{nan}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_value}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Apply a mask to a DataArray.

\sphinxAtStartPar
The grid and mask must already align for this function to work. An error
will be raised if the coordinate systems cannot be aligned.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} Observational DataArray to be masked by positions in the mask
DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} Array containing values used to mask the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the variable in the observational DataArray to apply the mask
to.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{masked\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value indicating masked values in the DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value to set masked values to in the observational DataFrame.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{grid} \textendash{} Input xarray.DataArray with the variable masked by the mask DataArray.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.DataArray

\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_dataset() (in module glomar\_gridding.mask)@\spxentry{mask\_dataset()}\spxextra{in module glomar\_gridding.mask}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.mask.mask_dataset}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.mask.}}\sphinxbfcode{\sphinxupquote{mask\_dataset}}}
{\sphinxparam{\DUrole{n}{dataset}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask}}\sphinxparamcomma \sphinxparam{\DUrole{n}{varnames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{masked\_value}\DUrole{o}{=}\DUrole{default_value}{nan}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_value}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Apply a mask to a DataSet.

\sphinxAtStartPar
The grid and mask must already align for this function to work. An error
will be raised if the coordinate systems cannot be aligned.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataset}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.Dataset}}) \textendash{} Observational Dataset to be masked by positions in the mask
DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} Array containing values used to mask the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varnames}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list containing the names of  variables in the observational Dataser
to apply the mask to.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{masked\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value indicating masked values in the DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value to set masked values to in the observational DataFrame.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{grid} \textendash{} Input xarray.Dataset with the variables masked by the mask DataArray.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.Dataset

\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_from\_obs\_array() (in module glomar\_gridding.mask)@\spxentry{mask\_from\_obs\_array()}\spxextra{in module glomar\_gridding.mask}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.mask.mask_from_obs_array}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.mask.}}\sphinxbfcode{\sphinxupquote{mask\_from\_obs\_array}}}
{\sphinxparam{\DUrole{n}{obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{datetime\_idx}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Infer a mask from an input array. Mask values are those where all values
are NaN along the time dimension.

\sphinxAtStartPar
An example use\sphinxhyphen{}case would be to infer land\sphinxhyphen{}points from a SST data array.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Array containing the observation values. Records that are numpy.nan
will count towards the mask, if all values in the datetime dimension
are numpy.nan.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datetime\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The index of the datetime, or grouping, dimension. If all records at
a point along this dimension are NaN then this point will be masked.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{mask} \textendash{} A boolean array with dimension reduced along the datetime dimension.
A True value indicates that all values along the datetime dimension
for this index are numpy.nan and are masked.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_from\_obs\_frame() (in module glomar\_gridding.mask)@\spxentry{mask\_from\_obs\_frame()}\spxextra{in module glomar\_gridding.mask}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.mask.mask_from_obs_frame}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.mask.}}\sphinxbfcode{\sphinxupquote{mask\_from\_obs\_frame}}}
{\sphinxparam{\DUrole{n}{obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{coords}}\sphinxparamcomma \sphinxparam{\DUrole{n}{datetime\_col}}\sphinxparamcomma \sphinxparam{\DUrole{n}{value\_col}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute a mask from observations.

\sphinxAtStartPar
Positions defined by the “coords” values that do not have any observations,
at any datetime value in the “datetime\_col”, for the “value\_col” field are
masked.

\sphinxAtStartPar
An example use\sphinxhyphen{}case would be to identify land positions from sst records.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} DataFrame containing observations over space and time. The values in
the “value\_col” field will be used to define the mask.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list of columns containing the coordinates used to define the mask.
For example {[}“lat”, “lon”{]}.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datetime\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the datetime column. Any positions that contain no records at
any datetime value are masked.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the column containing values from which the mask will be
defined.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{DataFrame}}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{polars.DataFrame containing coordinate columns and a Boolean “mask” column}

\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{indicating positions that contain no observations and would be a mask value.}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_observations() (in module glomar\_gridding.mask)@\spxentry{mask\_observations()}\spxextra{in module glomar\_gridding.mask}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.mask.mask_observations}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.mask.}}\sphinxbfcode{\sphinxupquote{mask\_observations}}}
{\sphinxparam{\DUrole{n}{obs}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask}}\sphinxparamcomma \sphinxparam{\DUrole{n}{varnames}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_varname}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}mask\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{masked\_value}\DUrole{o}{=}\DUrole{default_value}{nan}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_value}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_coords}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}lat\textquotesingle{}, \textquotesingle{}lon\textquotesingle{}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_coords}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}latitude\textquotesingle{}, \textquotesingle{}longitude\textquotesingle{}{]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{align\_to\_mask}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{drop}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask\_grid\_prefix}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\_mask\_grid\_\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Mask observations in a DataFrame subject to a mask DataArray.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} Observational DataFrame to be masked by positions in the mask
DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}) \textendash{} Array containing values used to mask the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varnames}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Columns in the observational DataFrame to apply the mask to.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_varname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the mask variable in the mask DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{masked\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value indicating masked values in the DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value to set masked values to in the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list of coordinate names in the observational DataFrame. Used to map
the mask DataArray to the observational DataFrame. The order must align
with the coordinates of the mask DataArray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list of coordinate names in the mask DataArray. These coordinates are
mapped onto the observational DataFrame in order to apply the mask. The
ordering of the coordinate names in this list must match those in the
obs\_coords list.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{align\_to\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Optionally align the observational DataFrame to the mask DataArray.
This essentially sets the mask’s grid as the output grid for
interpolation.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{drop}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Drop masked values in the observational DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask\_grid\_prefix}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Prefix to use for the mask gridbox index column in the observational
DataFrame.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{obs} \textendash{} Input polars.DataFrame containing additional column named by the
mask\_varname argument, indicating records that are masked. Masked values
are dropped if the drop argument is set to True.

\sphinxlineitem{Return type}
\sphinxAtStartPar
polars.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.distances@\spxentry{glomar\_gridding.distances}}\index{glomar\_gridding.distances@\spxentry{glomar\_gridding.distances}!module@\spxentry{module}}

\section{Distances}
\label{\detokenize{users_guide:distances}}\label{\detokenize{users_guide:module-glomar_gridding.distances}}
\sphinxAtStartPar
Functions for calculating distances or distance\sphinxhyphen{}based covariance components.

\sphinxAtStartPar
Some functions can be used for computing pairwise\sphinxhyphen{}distances, for example via
squareform. Some functions can be used as a distance function for
glomar\_gridding.error\_covariance.dist\_weights, accounting for the distance
component to an error covariance matrix.

\sphinxAtStartPar
Functions for computing covariance using Matern Tau by Steven Chan (@stchan).
\index{calculate\_distance\_matrix() (in module glomar\_gridding.distances)@\spxentry{calculate\_distance\_matrix()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.calculate_distance_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{calculate\_distance\_matrix}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dist\_func=\textless{}function haversine\_distance\_from\_frame\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lat\_col=\textquotesingle{}lat\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lon\_col=\textquotesingle{}lon\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Create a distance matrix from a DataFrame containing positional information,
typically latitude and longitude, using a distance function.

\sphinxAtStartPar
Available functions are \sphinxtitleref{haversine\_distance}, \sphinxtitleref{euclidean\_distance}. A
custom function can be used, requiring that the function takes the form:
(tuple{[}float, float{]}, tuple{[}float, float{]}) \sphinxhyphen{}\textgreater{} float
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} DataFrame containing latitude and longitude columns indicating the
positions between which distances are computed to form the distance
matrix

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}) \textendash{} The function used to calculate the pairwise distances. Functions
available for this function are \sphinxtitleref{haversine\_distance} and
\sphinxtitleref{euclidean\_distance}.
A custom function can be based, that takes as input two tuples of
positions (computing a single distance value between the pair of
positions). (tuple{[}float, float{]}, tuple{[}float, float{]}) \sphinxhyphen{}\textgreater{} float

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lat\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the column in the input DataFrame containing latitude values.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lon\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the column in the input DataFrame containing longitude values.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{dist} \textendash{} A matrix of pairwise distances.

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{displacements() (in module glomar\_gridding.distances)@\spxentry{displacements()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.displacements}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{displacements}}}
{\sphinxparam{\DUrole{n}{lats}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lons}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lats2}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lons2}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_x\_method}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate east\sphinxhyphen{}west and north\sphinxhyphen{}south displacement matrices for all pairs
of input positions.

\sphinxAtStartPar
The results are not scaled by any radius, this should be performed outside
of this function.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lats}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The latitudes of the positions, should be provided in degrees.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lons}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The longitudes of the positions, should be provided in degrees.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lats2}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The latitudes of the optional second positions, should be provided in
degrees.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lons2}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The longitudes of the optional second positions, should be provided in
degrees.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_x\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} One of “Met\_Office” or “Modified\_Met\_Office”. If set to None, the
displacements will be returned in degrees, rather than actual distance
values. Set to “Met\_Office” to use a cylindrical approximation, set
to “Modified\_Met\_Office” to use an approximation that uses the average
of the latitudes to set the horizontal displacement scale.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{disp\_y} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} The north\sphinxhyphen{}south displacements.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{disp\_x} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} The east\sphinxhyphen{}west displacements.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{euclidean\_distance() (in module glomar\_gridding.distances)@\spxentry{euclidean\_distance()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.euclidean_distance}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{euclidean\_distance}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{radius}\DUrole{o}{=}\DUrole{default_value}{6371.0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the Euclidean distance in kilometers between pairs of lat, lon
points on the earth (specified in decimal degrees).

\sphinxAtStartPar
See:
\sphinxurl{https://math.stackexchange.com/questions/29157/how-do-i-convert-the-distance-between-two-lat-long-points-into-feet-meters}
\sphinxurl{https://cesar.esa.int/upload/201709/Earth\_Coordinates\_Booklet.pdf}

\sphinxAtStartPar
d = SQRT((x\_2\sphinxhyphen{}x\_1)**2 + (y\_2\sphinxhyphen{}y\_1)**2 + (z\_2\sphinxhyphen{}z\_1)**2)

\sphinxAtStartPar
where

\sphinxAtStartPar
(x\_n y\_n z\_n) = ( Rcos(lat)cos(lon) Rcos(lat)sin(lon) Rsin(lat) )
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} DataFrame containing latitude and longitude columns indicating the
positions between which distances are computed to form the distance
matrix

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The radius of the sphere used for the calculation. Defaults to the
radius of the earth in km (6371.0 km).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{dist} \textendash{} The direct pairwise distance between the positions in the input
DataFrame through the sphere defined by the radius parameter.

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{haversine\_distance\_from\_frame() (in module glomar\_gridding.distances)@\spxentry{haversine\_distance\_from\_frame()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.haversine_distance_from_frame}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{haversine\_distance\_from\_frame}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{radius}\DUrole{o}{=}\DUrole{default_value}{6371}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the great circle distance in kilometers between pairs of lat, lon
points on the earth (specified in decimal degrees).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} DataFrame containing latitude and longitude columns indicating the
positions between which distances are computed to form the distance
matrix

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The radius of the sphere used for the calculation. Defaults to the
radius of the earth in km (6371.0 km).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{dist} \textendash{} The pairwise haversine distances between the inputs in the DataFrame,
on the sphere defined by the radius parameter.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{haversine\_gaussian() (in module glomar\_gridding.distances)@\spxentry{haversine\_gaussian()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.haversine_gaussian}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{haversine\_gaussian}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{R}\DUrole{o}{=}\DUrole{default_value}{6371.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{r}\DUrole{o}{=}\DUrole{default_value}{40}}\sphinxparamcomma \sphinxparam{\DUrole{n}{s}\DUrole{o}{=}\DUrole{default_value}{0.6}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Gaussian Haversine Model
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} Observations, required columns are “lat” and “lon” representing
latitude and longitude respectively.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{R}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Radius of the sphere on which Haversine distance is computed. Defaults
to radius of earth in km.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Gaussian model range parameter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Gaussian model scale parameter

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{C} \textendash{} Distance matrix for the input positions. Result has been modified using
the Gaussian model.

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{inv\_2d() (in module glomar\_gridding.distances)@\spxentry{inv\_2d()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.inv_2d}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{inv\_2d}}}
{\sphinxparam{\DUrole{n}{mat}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the inverse of a 2 x 2 matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mahal\_dist\_func() (in module glomar\_gridding.distances)@\spxentry{mahal\_dist\_func()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.mahal_dist_func}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{mahal\_dist\_func}}}
{\sphinxparam{\DUrole{n}{delta\_x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_y}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Lx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Ly}}\sphinxparamcomma \sphinxparam{\DUrole{n}{theta}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate tau from displacements, Lx, Ly, and theta (if it is known). For
an array of displacements, for a set of scalar ellipse parameters, Lx, Ly,
and theta.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_x}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} displacement to remote point as in: (delta\_x) i + (delta\_y) j in old
school vector notation

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_y}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} displacement to remote point as in: (delta\_x) i + (delta\_y) j in old
school vector notation

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Lx}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Lx, Ly scale (km or degrees)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Ly}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Lx, Ly scale (km or degrees)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} rotation angle in radians

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{tau} \textendash{} Mahalanobis distance

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{radial\_dist() (in module glomar\_gridding.distances)@\spxentry{radial\_dist()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.radial_dist}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{radial\_dist}}}
{\sphinxparam{\DUrole{n}{lat1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lon1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lat2}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lon2}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Computes a distance matrix of the coordinates using a spherical metric.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lat1}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} latitude of point A

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lon1}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} longitude of point A

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lat2}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} latitude of point B

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lon2}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} longitude of point B

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
Radial distance between point A and point B

\end{description}\end{quote}

\end{fulllineitems}

\index{rot\_mat() (in module glomar\_gridding.distances)@\spxentry{rot\_mat()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.rot_mat}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{rot\_mat}}}
{\sphinxparam{\DUrole{n}{angle}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute a 2d rotation matrix from an angle.

\sphinxAtStartPar
The input angle must be in radians
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{sigma\_rot\_func() (in module glomar\_gridding.distances)@\spxentry{sigma\_rot\_func()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.sigma_rot_func}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{sigma\_rot\_func}}}
{\sphinxparam{\DUrole{n}{Lx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Ly}}\sphinxparamcomma \sphinxparam{\DUrole{n}{theta}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Equation 15 in Karspeck el al 2011 and Equation 6
in Paciorek and Schervish 2006,
assuming Sigma(Lx, Ly, theta) locally/moving\sphinxhyphen{}window invariant or
we have already taken the mean (Sigma overbar, PP06 3.1.1)

\sphinxAtStartPar
Lx, Ly \sphinxhyphen{} anistropic variogram length scales
theta \sphinxhyphen{} angle relative to lines of constant latitude
theta should be radians, and the fitting code outputs radians by default
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{sigma} \textendash{} 2 x 2 matrix

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{tau\_dist() (in module glomar\_gridding.distances)@\spxentry{tau\_dist()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.tau_dist}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{tau\_dist}}}
{\sphinxparam{\DUrole{n}{dE}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dN}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sigma}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Eq.15 in Karspeck paper
but it is standard formulation to the
Mahalanobis distance
\sphinxurl{https://en.wikipedia.org/wiki/Mahalanobis\_distance}
10.1002/qj.900
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{tau\_dist\_from\_frame() (in module glomar\_gridding.distances)@\spxentry{tau\_dist\_from\_frame()}\spxextra{in module glomar\_gridding.distances}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.distances.tau_dist_from_frame}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.distances.}}\sphinxbfcode{\sphinxupquote{tau\_dist\_from\_frame}}}
{\sphinxparam{\DUrole{n}{df}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the tau/Mahalanobis matrix for all records within a gridbox

\sphinxAtStartPar
Can be used as an input function for observations.dist\_weight.

\sphinxAtStartPar
Eq.15 in Karspeck paper
but it is standard formulation to the
Mahalanobis distance
\sphinxurl{https://en.wikipedia.org/wiki/Mahalanobis\_distance}
10.1002/qj.900

\sphinxAtStartPar
By Steven Chan \sphinxhyphen{} @stchan
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} The observational DataFrame, containing positional information for each
observation (“lat”, “lon”), gridbox specific positional information
(“grid\_lat”, “grid\_lon”), and ellipse length\sphinxhyphen{}scale parameters used for
computation of \sphinxtitleref{sigma} (“grid\_lx”, “grid\_ly”, “grid\_theta”).

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{tau} \textendash{} A matrix of dimension n x n where n is the number of rows in \sphinxtitleref{df} and
is the tau/Mahalanobis distance.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.interpolation\_covariance@\spxentry{glomar\_gridding.interpolation\_covariance}}\index{glomar\_gridding.interpolation\_covariance@\spxentry{glomar\_gridding.interpolation\_covariance}!module@\spxentry{module}}

\section{Interpolation Covariance}
\label{\detokenize{users_guide:interpolation-covariance}}\label{\detokenize{users_guide:module-glomar_gridding.interpolation_covariance}}
\sphinxAtStartPar
Functions for computing (components of) the interpolation covariance matrix
used for the interpolation step.
\index{load\_covariance() (in module glomar\_gridding.interpolation\_covariance)@\spxentry{load\_covariance()}\spxextra{in module glomar\_gridding.interpolation\_covariance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.interpolation_covariance.load_covariance}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.interpolation\_covariance.}}\sphinxbfcode{\sphinxupquote{load\_covariance}}}
{\sphinxparam{\DUrole{n}{path}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cov\_var\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}covariance\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Load a covariance matrix from a netCDF file. Can input a filename or a
string to format with keyword arguments.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Full filename (including path), or filename with replacements using
str.format with named replacements. For example:
/path/to/global\_covariance\_\{month:02d\}.nc

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cov\_var\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the variable for the covariance matrix

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Keywords arguments matching the replacements in the input path.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{covariance} \textendash{} A numpy matrix containing the covariance matrix loaded from the netCDF
file determined by the input arguments.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.error\_covariance@\spxentry{glomar\_gridding.error\_covariance}}\index{glomar\_gridding.error\_covariance@\spxentry{glomar\_gridding.error\_covariance}!module@\spxentry{module}}

\section{Error Covariance}
\label{\detokenize{users_guide:error-covariance}}\label{\detokenize{users_guide:module-glomar_gridding.error_covariance}}
\sphinxAtStartPar
Functions for computing correlated and uncorrelated components of the error
covariance. These values are determined from standard deviation (sigma) values
assigned to groupings within the observational data.

\sphinxAtStartPar
The correlated components will form a matrix that is permutationally equivalent
to a block diagonal matrix (i.e. the matrix will be block diagonal if the
observational data is sorted by the group).

\sphinxAtStartPar
The uncorrelated components will form a diagonal matrix.

\sphinxAtStartPar
Further a distance\sphinxhyphen{}based component can be constructed, where distances between
records within the same grid box are evaluated.

\sphinxAtStartPar
The functions in this module are valid for observational data where there could
be more than 1 observation in a gridbox.
\index{correlated\_components() (in module glomar\_gridding.error\_covariance)@\spxentry{correlated\_components()}\spxextra{in module glomar\_gridding.error\_covariance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.error_covariance.correlated_components}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.error\_covariance.}}\sphinxbfcode{\sphinxupquote{correlated\_components}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{group\_col}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bias\_sig\_col}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bias\_sig\_map}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Returns measurements covariance matrix updated by adding bias uncertainty to
the measurements based on a grouping within the observational data.

\sphinxAtStartPar
The result is equivalent to a block diagonal matrix via permutation. If the
input observational data is sorted by the group column then the resulting
matrix is block diagonal, where the blocks are the size of each grouping.
The values in each block are the square of the sigma value associated with
the grouping.

\sphinxAtStartPar
Note that in most cases the output is not a block\sphinxhyphen{}diagonal, as the input
is not usually sorted by the group column. In most processing cases, the
input dataframe will be sorted by the gridbox index.

\sphinxAtStartPar
The values can either be pre\sphinxhyphen{}defined in the observational dataframe, and
can be indicated by the “bias\_val\_col” argument. Alternatively, a mapping
can be passed, the values will be then assigned by this mapping of group to
sigma.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} Observational DataFrame including group information and bias uncertainty
values for each grouping. It is assumed that a single bias uncertainty
value applies to the whole group, and is applied as cross terms in the
covariance matrix (plus to the diagonal).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{group\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the column that can be used to partition the observational
DataFrame.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bias\_sig\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Name of the column containing bias uncertainty values for each of
the groups identified by ‘group\_col’. It is assumed that a single bias
uncertainty value applies to the whole group, and is applied as cross
terms in the covariance matrix (plus to the diagonal).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bias\_sig\_map}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Mapping between values in the group\_col and bias uncertainty values,
if bias\_val\_col is not in the DataFrame.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
The correlated components of the error covariance.

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_weight() (in module glomar\_gridding.error\_covariance)@\spxentry{dist\_weight()}\spxextra{in module glomar\_gridding.error\_covariance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.error_covariance.dist_weight}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.error\_covariance.}}\sphinxbfcode{\sphinxupquote{dist\_weight}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dist\_fn}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid\_idx}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}grid\_idx\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{dist\_kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the distance and weight matrices over gridboxes for an input Frame.

\sphinxAtStartPar
This function acts as a wrapper for a distance function, allowing for
computation of the distances between positions in the same gridbox using any
distance metric.

\sphinxAtStartPar
The weightings from this function are for the gridbox mean of the
observations within a gridbox.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} The observation DataFrame, containing the columns required for
computation of the distance matrix. Contains the “grid\_idx” column which
indicates the gridbox for a given observation. The index of the
DataFrame should match the index ordering for the output distance
matrix/weights.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist\_fn}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}) \textendash{}
\sphinxAtStartPar
The function used to compute a distance matrix for all points in a given
grid\sphinxhyphen{}cell. Takes as input a polars.DataFrame as first argument. Any
other arguments should be constant over all gridboxes, or can be a
look\sphinxhyphen{}up table that can use values in the DataFrame to specify values
specific to a gridbox. The function should return a numpy matrix, which
is the distance matrix for the gridbox only. This wrapper function will
correctly apply this matrix to the larger distance matrix using the
index from the DataFrame.

\sphinxAtStartPar
If dist\_fn is None, then no distances are computed and None is returned
for the dist value.


\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{**dist\_kwargs}} \textendash{} Arguments to be passed to dist\_fn. In general these should be constant
across all gridboxes. It is possible to pass a look\sphinxhyphen{}up table that
contains pre\sphinxhyphen{}computed values that are gridbox specific, if the keys can
be matched to a column in df.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{dist} (\sphinxstyleemphasis{numpy.matrix}) \textendash{} The distance matrix, which contains the same number of rows and columns
as rows in the input DataFrame df. The values in the matrix are 0 if the
indices of the row/column are for observations from different gridboxes,
and non\sphinxhyphen{}zero if the row/column indices fall within the same gridbox.
Consequently, with appropriate re\sphinxhyphen{}arrangement of rows and columns this
matrix can be transformed into a block\sphinxhyphen{}diagonal matrix. If the DataFrame
input is pre\sphinxhyphen{}sorted by the gridbox column, then the result is a
block\sphinxhyphen{}diagonal matrix.

\sphinxAtStartPar
If dist\_fn is None, then this value will be None.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{weights} (\sphinxstyleemphasis{numpy.matrix}) \textendash{} A matrix of weights. This has dimensions n x p where n is the number of
unique gridboxes and p is the number of observations (the number of rows
in df). The values are 0 if the row and column do not correspond to the
same gridbox and equal to the inverse of the number of observations in a
gridbox if the row and column indices fall within the same gridbox. The
rows of weights are in a sorted order of the gridbox. Should this be
incorrect, one should re\sphinxhyphen{}arrange the rows after calling this function.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_weights() (in module glomar\_gridding.error\_covariance)@\spxentry{get\_weights()}\spxextra{in module glomar\_gridding.error\_covariance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.error_covariance.get_weights}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.error\_covariance.}}\sphinxbfcode{\sphinxupquote{get\_weights}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{grid\_idx}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}grid\_idx\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get just the weight matrices over gridboxes for an input Frame.

\sphinxAtStartPar
The weightings from this function are for the gridbox mean of the
observations within a gridbox.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} The observation DataFrame, containing the columns required for
computation of the distance matrix. Contains the “grid\_idx” column which
indicates the gridbox for a given observation. The index of the
DataFrame should match the index ordering for the output weights.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grid\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the column containing the gridbox index from the output grid.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{weights} \textendash{} A matrix of weights. This has dimensions n x p where n is the number of
unique gridboxes and p is the number of observations (the number of rows
in df). The values are 0 if the row and column do not correspond to the
same gridbox and equal to the inverse of the number of observations in a
gridbox if the row and column indices fall within the same gridbox. The
rows of weights are in a sorted order of the gridbox. Should this be
incorrect, one should re\sphinxhyphen{}arrange the rows after calling this function.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{uncorrelated\_components() (in module glomar\_gridding.error\_covariance)@\spxentry{uncorrelated\_components()}\spxextra{in module glomar\_gridding.error\_covariance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.error_covariance.uncorrelated_components}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.error\_covariance.}}\sphinxbfcode{\sphinxupquote{uncorrelated\_components}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{group\_col}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}data\_type\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_sig\_col}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{obs\_sig\_map}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the covariance matrix of the measurements (observations). This
is the uncorrelated component of the covariance.

\sphinxAtStartPar
The result is a diagonal matrix. The diagonal is formed by the square of the
sigma values associated with the values in the grouping.

\sphinxAtStartPar
The values can either be pre\sphinxhyphen{}defined in the observational dataframe, and
can be indicated by the “bias\_val\_col” argument. Alternatively, a mapping
can be passed, the values will be then assigned by this mapping of group to
sigma.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} The observational DataFrame containing values to group by.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{group\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the group column to use to set observational sigma values.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_sig\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Name of the column containing observational sigma values. If set and
present in the DataFrame, then this column is used as the diagonal of
the returned covariance matrix.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs\_sig\_map}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Mapping between group and observational sigma values used to define
the diagonal of the returned covariance matrix.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{A diagonal matrix representing the uncorrelated components of the error}

\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{covariance matrix.}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.ellipse@\spxentry{glomar\_gridding.ellipse}}\index{glomar\_gridding.ellipse@\spxentry{glomar\_gridding.ellipse}!module@\spxentry{module}}

\section{Ellipse Models}
\label{\detokenize{users_guide:ellipse-models}}\label{\detokenize{users_guide:module-glomar_gridding.ellipse}}
\sphinxAtStartPar
Classes and functions for ellipse models.
\index{EllipseModel (class in glomar\_gridding.ellipse)@\spxentry{EllipseModel}\spxextra{class in glomar\_gridding.ellipse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse.EllipseModel}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.ellipse.}}\sphinxbfcode{\sphinxupquote{EllipseModel}}}
{\sphinxparam{\DUrole{n}{anisotropic}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rotated}}\sphinxparamcomma \sphinxparam{\DUrole{n}{physical\_distance}}\sphinxparamcomma \sphinxparam{\DUrole{n}{v}}\sphinxparamcomma \sphinxparam{\DUrole{n}{unit\_sigma}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
The class that contains variogram/ellipse fitting methods and parameters

\sphinxAtStartPar
This class assumes your input to be a standardised correlation matrix
They are easier to handle because stdevs in the covariance function become 1
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{anisotropic}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Should the output be an ellipse? Set to False for circle.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rotated}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Can the ellipse be rotated. If anisotropic is False this value cannot
be True.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{physical\_distance}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Use physical distances rather than lat/lon distance.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Matern Shape Parameter. Must be \textgreater{} 0.0.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{unit\_sigma=True}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{}
\sphinxAtStartPar
When MLE fitting the Matern parameters,
assuming the Matern parameters themselves
are normally distributed,
there is standard deviation within the log likelihood function.

\sphinxAtStartPar
See Wikipedia entry for Maximum Likelihood under:
\sphinxhyphen{} Continuous distribution, continuous parameter space

\sphinxAtStartPar
Its actual value is not important
to the best (MLE) estimate of the Matern parameters.
If one assumes the parameters are normally distributed,
the mean (best estimate) is independent of its variance.
In fact in Karspeck et al 2012, it is simply set to 1 (Eq B1).
This value can however be computed. It serves a similar purpose as
the original standard deviation:
in this case, how the actual observed semivariance disperses
around the fitted variogram.

\sphinxAtStartPar
The choice to default to 1 follows Karspeck et al. 2012


\end{itemize}

\end{description}\end{quote}
\index{fit() (glomar\_gridding.ellipse.EllipseModel method)@\spxentry{fit()}\spxextra{glomar\_gridding.ellipse.EllipseModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse.EllipseModel.fit}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{fit}}}
{\sphinxparam{\DUrole{n}{X}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y}}\sphinxparamcomma \sphinxparam{\DUrole{n}{guesses}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Nelder\sphinxhyphen{}Mead\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{estimate\_SE}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}bootstrap\_parallel\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_sim}\DUrole{o}{=}\DUrole{default_value}{500}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_jobs}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{backend}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}loky\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{random\_seed}\DUrole{o}{=}\DUrole{default_value}{1234}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Default solver in Nelder\sphinxhyphen{}Mead as used in the Karspeck paper
\sphinxurl{https://docs.scipy.org/doc/scipy/reference/optimize.minimize-neldermead.html}
default max\sphinxhyphen{}iter is 200 x (number\_of\_variables)
for 3 variables (Lx, Ly, theta) \textendash{}\textgreater{} 200x3 = 600
note: unlike variogram fitting, no nugget, no sill, and no residue
variance (normalised data but Fisher transform needed?)
can be adjusted using “maxiter” within “options” kwargs

\sphinxAtStartPar
Much of the variable names are defined the same way as earlier
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Array of displacements. Expected to be 1\sphinxhyphen{}dimensional if the ellipse
model is not anisotropic, 2\sphinxhyphen{}dimensional otherwise. In units of km if
the ellipse uses physical distances, otherwise in degrees. The
displacements are from each position within the test region to the
centre of the ellipse.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Vector of observed correlations between the centre of the ellipse
and each test point.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{guesses=None}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} List of initial values to scipy.optimize.minimize, default guesses
for the ellipse model are used if not set.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bounds=None}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Tuples/lists of bounds for fitted parameters. Default bounds for
the ellipse model are used if not set.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} scipy.optimize.minimize optimisation method. Defaults to
“Nelder\sphinxhyphen{}Mead”. See \sphinxurl{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html}
for valid values.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tol=None}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} scipy.optimize.minimize convergence tolerance

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{estimate\_SE=\textquotesingle{}bootstrap\_parallel\textquotesingle{}}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} How to estimate standard error if needed. If not set no standard
error is computed.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_sim=500}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bootstrap to estimate standard error

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_jobs=DEFAULT\_N\_JOBS}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of threads for bootstrapping if \sphinxtitleref{estimate\_SE} is set to
“bootstrap\_parallel”.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend=DEFAULT\_BACKEND}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} joblib backend for bootstrapping.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{random\_seed=1234}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Random seed for bootstrap

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{OptimizeResult}}, \sphinxcode{\sphinxupquote{float}} | \sphinxcode{\sphinxupquote{None}}, \sphinxcode{\sphinxupquote{list}}{[}\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{float}}, \sphinxcode{\sphinxupquote{float}}{]}{]}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{results} (\sphinxstyleemphasis{OptimizeResult}) \textendash{} Output of scipy.optimize.minimize

\item {}
\sphinxAtStartPar
\sphinxstylestrong{SE} (\sphinxstyleemphasis{float | None}) \textendash{} Standard error of the fitted parameters

\item {}
\sphinxAtStartPar
\sphinxstylestrong{bounds} (\sphinxstyleemphasis{list{[}tuple{[}float, …{]}{]}}) \textendash{} Bounds of fitted parameters

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{negative\_log\_likelihood() (glomar\_gridding.ellipse.EllipseModel method)@\spxentry{negative\_log\_likelihood()}\spxextra{glomar\_gridding.ellipse.EllipseModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse.EllipseModel.negative_log_likelihood}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{negative\_log\_likelihood}}}
{\sphinxparam{\DUrole{n}{X}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y}}\sphinxparamcomma \sphinxparam{\DUrole{n}{params}}\sphinxparamcomma \sphinxparam{\DUrole{n}{arctanh\_transform}\DUrole{o}{=}\DUrole{default_value}{True}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the negative log\sphinxhyphen{}likelihood given observed X independent
observations (displacements) and y dependent variable (the observed
correlation), and Matern parameters params. Namely does the Matern
covariance function using params, how close it explains the observed
displacements and correlations.

\sphinxAtStartPar
log(LL) = SUM (f (y,x|params) )
params = Maximise (log(LL))
params = Minimise (\sphinxhyphen{}log(LL)) which is how usually the computer solves it
assuming errors of params are normally distributed

\sphinxAtStartPar
There is a hidden scale/standard deviation in
stats.norm.logpdf(scale, which defaults to 1)
but since we have scaled our values to covariance to correlation (and
even used Fisher transform) as part of the function, it can be dropped

\sphinxAtStartPar
Otherwise, you need to have stdev as the last value of params, and
should be set to the scale parameter
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Observed displacements to the centre of the ellipse.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Observed correlation against the centre of the ellipse.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Ellipse parameters (in the current optimize iteration) or if you
want to compute the actual negative log\sphinxhyphen{}likelihood.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arctanh\_transform}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Should the Fisher (arctanh) transform be used
This is usually option, but it does make the computation
more stable if they are close to 1 (or \sphinxhyphen{}1; doesn’t apply here)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{nLL} \textendash{} The negative log likelihood

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{negative\_log\_likelihood\_function() (glomar\_gridding.ellipse.EllipseModel method)@\spxentry{negative\_log\_likelihood\_function()}\spxextra{glomar\_gridding.ellipse.EllipseModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse.EllipseModel.negative_log_likelihood_function}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{negative\_log\_likelihood\_function}}}
{\sphinxparam{\DUrole{n}{X}}\sphinxparamcomma \sphinxparam{\DUrole{n}{y}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Creates a function that can be fed into scipy.optimizer.minimize
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{Callable}}{[}{[}\sphinxcode{\sphinxupquote{list}}{[}\sphinxcode{\sphinxupquote{float}}{]}{]}, \sphinxcode{\sphinxupquote{float}}{]}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{cov\_ij\_anisotropic() (in module glomar\_gridding.ellipse)@\spxentry{cov\_ij\_anisotropic()}\spxextra{in module glomar\_gridding.ellipse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse.cov_ij_anisotropic}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.ellipse.}}\sphinxbfcode{\sphinxupquote{cov\_ij\_anisotropic}}}
{\sphinxparam{\DUrole{n}{v}}\sphinxparamcomma \sphinxparam{\DUrole{n}{stdev}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_y}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Lx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Ly}}\sphinxparamcomma \sphinxparam{\DUrole{n}{stdev\_j}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{theta}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Covariance structure between base point i and j
Assuming local stationarity or slowly varying
so that some terms in PS06 drops off (like Sigma\_i \textasciitilde{} Sigma\_j instead of
treating them as different) (aka second\_term below)
this makes formulation a lot more simple
We let stdev\_j opens to changes,
but in pracitice, we normalise everything to correlation so
stdev == stdev\_j == 1
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Matern shape parameter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stdev}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation at the centre of the ellipse

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_x}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Displacements to remote point as in: (delta\_x) i + (delta\_y) j in old
school vector notation

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_y}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Displacements to remote point as in: (delta\_x) i + (delta\_y) j in old
school vector notation

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Lx}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Lx, Ly scale (km or degrees)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Ly}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Lx, Ly scale (km or degrees)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stdev\_j}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Standard deviation, remote point. If set to None, then ‘stdev’ is used.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Rotation angle of the ellipse in radians.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{cov\_ij} \textendash{} Covariance/correlation between local and remote point given displacement
and Matern covariance parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{cov\_ij\_isotropic() (in module glomar\_gridding.ellipse)@\spxentry{cov\_ij\_isotropic()}\spxextra{in module glomar\_gridding.ellipse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse.cov_ij_isotropic}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.ellipse.}}\sphinxbfcode{\sphinxupquote{cov\_ij\_isotropic}}}
{\sphinxparam{\DUrole{n}{v}}\sphinxparamcomma \sphinxparam{\DUrole{n}{stdev}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta}}\sphinxparamcomma \sphinxparam{\DUrole{n}{R}}\sphinxparamcomma \sphinxparam{\DUrole{n}{stdev\_j}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Isotropic version of cov\_ij\_anisotropic. This makes the assumption that
Lx = Ly = R, i.e. that the model is a circle.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Matern shape parameter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stdev}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation, local point

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Displacements to remote point

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{R}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Range parameter (km or degrees)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stdev\_j}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation, remote point

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{cov\_ij} \textendash{} Covariance/correlation between local and remote point given displacement
and Matern covariance parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.ellipse\_builder@\spxentry{glomar\_gridding.ellipse\_builder}}\index{glomar\_gridding.ellipse\_builder@\spxentry{glomar\_gridding.ellipse\_builder}!module@\spxentry{module}}

\section{Ellipse Parameter Estimation}
\label{\detokenize{users_guide:ellipse-parameter-estimation}}\label{\detokenize{users_guide:module-glomar_gridding.ellipse_builder}}
\sphinxAtStartPar
Class to calculate the covariance (and correlation) of gridded observed data
over time. These values are used to estimate the ellipse parameters with an
instance of \sphinxtitleref{glomar\_gridding.ellipse.EllipseModel} as a reference.
\index{EllipseBuilder (class in glomar\_gridding.ellipse\_builder)@\spxentry{EllipseBuilder}\spxextra{class in glomar\_gridding.ellipse\_builder}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_builder.EllipseBuilder}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.ellipse\_builder.}}\sphinxbfcode{\sphinxupquote{EllipseBuilder}}}
{\sphinxparam{\DUrole{n}{data\_array}}\sphinxparamcomma \sphinxparam{\DUrole{n}{coords}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Class to build spatial covariance and correlation matrices used to estimate
ellipse parameterss using an instance of EllipseModel which sets up the
defaults for a given configuration.

\sphinxAtStartPar
To fit ellipse parameters to the correlation of the input data\_array, call
self.fit\_ellipse\_model.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ma.MaskedArray}}) \textendash{} Training data stored within a numpy array. In general, this input should
be extracted from an xarray.DataArray, and masked appropriately.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.Coordinates}}) \textendash{} The coordinates associated with the data\_array value. It is expected
that these are {[}“time”, “latitude”, “longitude”{]}

\end{itemize}

\end{description}\end{quote}
\index{calc\_cov() (glomar\_gridding.ellipse\_builder.EllipseBuilder method)@\spxentry{calc\_cov()}\spxextra{glomar\_gridding.ellipse\_builder.EllipseBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_builder.EllipseBuilder.calc_cov}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{calc\_cov}}}
{\sphinxparam{\DUrole{n}{rounding}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate covariance and correlation matrices.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rounding}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Round the values of the output.

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_params() (glomar\_gridding.ellipse\_builder.EllipseBuilder method)@\spxentry{compute\_params()}\spxextra{glomar\_gridding.ellipse\_builder.EllipseBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_builder.EllipseBuilder.compute_params}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{compute\_params}}}
{\sphinxparam{\DUrole{n}{default\_value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{matern\_ellipse}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_distance}\DUrole{o}{=}\DUrole{default_value}{20.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{min\_distance}\DUrole{o}{=}\DUrole{default_value}{0.3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_x\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Modified\_Met\_Office\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{guesses}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Nelder\sphinxhyphen{}Mead\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{0.001}}\sphinxparamcomma \sphinxparam{\DUrole{n}{estimate\_SE}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_jobs}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_sim}\DUrole{o}{=}\DUrole{default_value}{500}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit ellipses/covariance models using adhoc local covariances to all
unmasked grid points

\sphinxAtStartPar
The form of the covariance model depends on the “fform” attribute of the
Ellipse model:
\begin{itemize}
\item {}
\sphinxAtStartPar
isotropic (radial distance only)

\item {}
\sphinxAtStartPar
anistropic (x and y are different, but not rotated)

\item {}
\sphinxAtStartPar
anistropic\_rotated (rotated)

\end{itemize}

\sphinxAtStartPar
If the “fform” attribute ends with \_pd then physical distances are used
instead of degrees

\sphinxAtStartPar
range is defined max\_distance (either in km and degrees)
default is in degrees, but needs to be km if fform is from \_pd series
\textless{}— likely to be wrong: max\_distance should only be in degrees

\sphinxAtStartPar
there is also a min\_distance in which values,
matern function is not defined at the origin, so the 0.0 needs to
removed

\sphinxAtStartPar
v = matern covariance function shape parameter
Karspeck et al and Paciorek and Schervish use 3 and 4
but 0.5 and 1.5 are popular
0.5 gives an exponential decay
lim v\textendash{}\textgreater{}inf, Gaussian shape

\sphinxAtStartPar
delta\_x\_method: only meaningful for \_pd fits:
\begin{itemize}
\item {}
\sphinxAtStartPar
“Met\_Office”: Cylindrical Earth delta\_x = 6400km x delta\_lon
(in radians)

\item {}
\sphinxAtStartPar
“Modified\_Met\_Office”: uses the average zonal dist at different
lat

\end{itemize}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{}
\sphinxAtStartPar
Default value(s) to fill arrays where parameter estimation is not
possible (typically due to masking). Typically, one should set a
value that is appropriate to the type of the field. If a single
value is provided, this is used for all fields. If not, 6 values
should be provided for the following fields:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Lx \sphinxhyphen{} this should be a float or np.float value \sphinxhyphen{} a negative
value would be a good choice.

\item {}
\sphinxAtStartPar
Ly \sphinxhyphen{} this should be a float or np.float value \sphinxhyphen{} a negative
value would be a good choice.

\item {}
\sphinxAtStartPar
theta \sphinxhyphen{} this should be a float or np.float value \sphinxhyphen{} a large
value would be a good choice.

\item {}
\sphinxAtStartPar
stdev \sphinxhyphen{} this should be a float or np.float value \sphinxhyphen{} a negative
value would be a good choice.

\item {}
\sphinxAtStartPar
success \sphinxhyphen{} this should be a int or np.int value \sphinxhyphen{} a negative
value would be a good choice.

\item {}
\sphinxAtStartPar
niter \sphinxhyphen{} this should be a int or np.int value \sphinxhyphen{} a negative
value would be a good choice.

\end{enumerate}


\end{description}\end{quote}
\begin{description}
\sphinxlineitem{matern\_ellipse}{[}EllipseModel{]}
\sphinxAtStartPar
EllipseModel to use for parameter estimation

\sphinxlineitem{max\_distance}{[}float{]}
\sphinxAtStartPar
Maximum separation in distance unit that data will be fed
into parameter fitting
Units depend on fform (it is usually either degrees or km)

\sphinxlineitem{min\_distance: float}
\sphinxAtStartPar
Minimum separation in distance unit that data
will be fed into parameter fitting
Units depend on fform (it is usually either degrees or km)
Note: Due to the way we compute the Matern function,
it is undefined at dist == 0 even if the limit \sphinxhyphen{}\textgreater{} zero is obvious.

\sphinxlineitem{delta\_x\_method=”Modified\_Met\_Office”: str}
\sphinxAtStartPar
How to compute distances between grid points
For istropic variogram/covariances, this is a trivial problem;
you can just take the haversine or
Euclidean (“tunnel”) distance as they are non\sphinxhyphen{}directional.

\sphinxAtStartPar
But it is non trivial for anistropic cases,
you have to define a set of orthogonal space. In HadSST4,
Earth is assumed to be cylindrical “tin can” Earth,
so you can just define the orthogonal space by
lines of constant lat and lon (delta\_x\_method=”Met\_Office”).

\sphinxAtStartPar
The modified “Modified\_Met\_Office” is a variation to that,
but allow the tin can get squished at the poles.
(Sinusoidal projection). This does results in a problem:
the zonal displacement now depends in which latitude
you compute on (at the beginning latitude or at the end latitude).
Here we take the average of the two.

\sphinxlineitem{guesses=None: tuple of floats; None uses default guess values}
\sphinxAtStartPar
Initial guess values that get feeds in the optimizer for MLE.
In scipy, you are required to do so (but R often doesn’t).
You should anyway; sometimes they do funny things
if you don’t (per recommendation of David Stephenson)

\sphinxlineitem{bounds=None: tuple of floats; None uses default bounds values}
\sphinxAtStartPar
This is essentially a Bayesian “uniformative prior”
that forces convergence if the optimizer hits the bound.
For lower resolution fitting, this is rarely a problem.
For higher resolution fits, this often interacts with
the limit of the data you can put into the fit the optimizer
may fail to converge if the input data is very smooth (aka ENSO
region, where anomalies are smooth over very large (\textasciitilde{}10000km)
scales).

\sphinxlineitem{opt\_method=’Nelder\sphinxhyphen{}Mead’: str}
\sphinxAtStartPar
scipy.optimize method. Nelder\sphinxhyphen{}Mead is the one used by Karspeck.
See \sphinxurl{https://docs.scipy.org/doc/scipy/tutorial/optimize.html}
for valid options

\sphinxlineitem{tol=0.001: float}
\sphinxAtStartPar
Set convergence tolerance for scipy optimize.
See \sphinxurl{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\#scipy.optimize.minimize}

\sphinxAtStartPar
Note on new tol kwarg:
For N\sphinxhyphen{}M, this sets the value to both xatol and fatol
Default is 1E\sphinxhyphen{}4 (?)
Since it affects accuracy of all values including rotation
rotation angle 0.001 rad \textasciitilde{} 0.05 deg

\sphinxlineitem{estimate\_SE=None}{[}str | None{]}
\sphinxAtStartPar
The code can estimate the standard error if the Matern parameters.
This is not usually used or discussed for the purpose of kriging.
Certain opt\_method (gradient descent) can do this automatically
using Fisher Info for certain covariance function,
but is not possible for some nasty functions (aka Bessel
func) gets involved nor it is possible for some optimisers
(such as Nelder\sphinxhyphen{}Mead).
The code does it using bootstrapping.

\sphinxlineitem{n\_jobs=DEFAULT\_N\_JOBS: int}
\sphinxAtStartPar
If parallel processing, number of threads to use.

\sphinxlineitem{n\_sim}{[}int{]}
\sphinxAtStartPar
Number of simulations to bootstrap for SE estimation.

\end{description}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar

\sphinxAtStartPar
\sphinxstylestrong{params} \textendash{} Containing arrays for each parameter in the ellipse model class.
Note that one array is likely to be “qc\_code”, which takes values:
\begin{itemize}
\item {}
\sphinxAtStartPar
0: success

\item {}
\sphinxAtStartPar
2: success but with one parameter reaching upper
boundaries

\item {}
\sphinxAtStartPar
3: success with multiple parameters reaching the
boundaries (aka both Lx and Ly), can be both at lower or
upper boundaries

\item {}
\sphinxAtStartPar
9: fail, probably due to running out of maxiter (see
scipy.optimize.minimize kwargs “options)”

\end{itemize}


\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.Dataset

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_nearest\_xy\_index\_in\_cov\_matrix() (glomar\_gridding.ellipse\_builder.EllipseBuilder method)@\spxentry{find\_nearest\_xy\_index\_in\_cov\_matrix()}\spxextra{glomar\_gridding.ellipse\_builder.EllipseBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_builder.EllipseBuilder.find_nearest_xy_index_in_cov_matrix}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{find\_nearest\_xy\_index\_in\_cov\_matrix}}}
{\sphinxparam{\DUrole{n}{lonlat}}\sphinxparamcomma \sphinxparam{\DUrole{n}{use\_full}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Find the nearest column/row index of the covariance
that corresponds to a specific lat lon
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\end{description}\end{quote}

\end{fulllineitems}

\index{fit\_ellipse\_model() (glomar\_gridding.ellipse\_builder.EllipseBuilder method)@\spxentry{fit\_ellipse\_model()}\spxextra{glomar\_gridding.ellipse\_builder.EllipseBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_builder.EllipseBuilder.fit_ellipse_model}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{fit\_ellipse\_model}}}
{\sphinxparam{\DUrole{n}{xy\_point}}\sphinxparamcomma \sphinxparam{\DUrole{n}{matern\_ellipse}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_distance}\DUrole{o}{=}\DUrole{default_value}{20.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{min\_distance}\DUrole{o}{=}\DUrole{default_value}{0.3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_x\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Modified\_Met\_Office\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{guesses}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{opt\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Nelder\sphinxhyphen{}Mead\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{0.001}}\sphinxparamcomma \sphinxparam{\DUrole{n}{estimate\_SE}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_jobs}\DUrole{o}{=}\DUrole{default_value}{4}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_sim}\DUrole{o}{=}\DUrole{default_value}{500}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Fit ellipses/covariance models using adhoc local covariances

\sphinxAtStartPar
the form of the covariance model depends on the “fform” attribute of the
Ellipse model:
\begin{quote}

\sphinxAtStartPar
isotropic (radial distance only)
anistropic (x and y are different, but not rotated)
anistropic\_rotated (rotated)
\end{quote}

\sphinxAtStartPar
If the “fform” attribute ends with \_pd then physical distances are used
instead of degrees

\sphinxAtStartPar
range is defined max\_distance (either in km and degrees)
default is in degrees, but needs to be km if fform is from \_pd series
\textless{}— likely to be wrong: max\_distance should only be in degrees

\sphinxAtStartPar
there is also a min\_distance in which values,
matern function is not defined at the origin, so the 0.0 needs to
removed

\sphinxAtStartPar
v = matern covariance function shape parameter
Karspeck et al and Paciorek and Schervish use 3 and 4
but 0.5 and 1.5 are popular
0.5 gives an exponential decay
lim v\textendash{}\textgreater{}inf, Gaussian shape
\begin{description}
\sphinxlineitem{delta\_x\_method: only meaningful for \_pd fits:}\begin{itemize}
\item {}
\sphinxAtStartPar
“Met\_Office”: Cylindrical Earth delta\_x = 6400km x delta\_lon
(in radians)

\item {}
\sphinxAtStartPar
“Modified\_Met\_Office”: uses the average zonal dist at different
lat

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xy\_point}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The index point where ellipses will be fitted to

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_distance}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Maximum separation in distance unit that data will be fed
into parameter fitting
Units depend on fform (it is usually either degrees or km)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_distance}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minimum separation in distance unit that data
will be fed into parameter fitting
Units depend on fform (it is usually either degrees or km)
Note: Due to the way we compute the Matern function,
it is undefined at dist == 0 even if the limit \sphinxhyphen{}\textgreater{} zero is obvious.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_x\_method="Modified\_Met\_Office"}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{}
\sphinxAtStartPar
How to compute distances between grid points
For istropic variogram/covariances, this is a trivial problem;
you can just take the haversine or
Euclidean (“tunnel”) distance as they are non\sphinxhyphen{}directional.

\sphinxAtStartPar
But it is non trivial for anistropic cases,
you have to define a set of orthogonal space. In HadSST4,
Earth is assumed to be cylindrical “tin can” Earth,
so you can just define the orthogonal space by
lines of constant lat and lon (delta\_x\_method=”Met\_Office”).

\sphinxAtStartPar
The modified “Modified\_Met\_Office” is a variation to that,
but allow the tin can get squished at the poles.
(Sinusoidal projection). This does results in a problem:
the zonal displacement now depends in which latitude
you compute on (at the beginning latitude or at the end latitude).
Here we take the average of the two.


\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{guesses=None}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{floats; None uses default guess values}}) \textendash{} Initial guess values that get feeds in the optimizer for MLE.
In scipy, you are required to do so (but R often doesn’t).
You should anyway; sometimes they do funny things
if you don’t (per recommendation of David Stephenson)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bounds=None}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{floats; None uses default bounds values}}) \textendash{} This is essentially a Bayesian “uniformative prior”
that forces convergence if the optimizer hits the bound.
For lower resolution fitting, this is rarely a problem.
For higher resolution fits, this often interacts with
the limit of the data you can put into the fit the optimizer
may fail to converge if the input data is very smooth (aka ENSO
region, where anomalies are smooth over very large (\textasciitilde{}10000km)
scales).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{opt\_method=\textquotesingle{}Nelder\sphinxhyphen{}Mead\textquotesingle{}}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} scipy.optimize method. Nelder\sphinxhyphen{}Mead is the one used by Karspeck.
See \sphinxurl{https://docs.scipy.org/doc/scipy/tutorial/optimize.html}
for valid options

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tol=0.001}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{}
\sphinxAtStartPar
Set convergence tolerance for scipy optimize.
See \sphinxurl{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\#scipy.optimize.minimize}

\sphinxAtStartPar
Note on new tol kwarg:
For N\sphinxhyphen{}M, this sets the value to both xatol and fatol
Default is 1E\sphinxhyphen{}4 (?)
Since it affects accuracy of all values including rotation
rotation angle 0.001 rad \textasciitilde{} 0.05 deg


\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{estimate\_SE=None}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} The code can estimate the standard error if the Matern parameters.
This is not usually used or discussed for the purpose of kriging.
Certain opt\_method (gradient descent) can do this automatically
using Fisher Info for certain covariance function,
but is not possible for some nasty functions (aka Bessel
func) gets involved nor it is possible for some optimisers
(such as Nelder\sphinxhyphen{}Mead).
The code does it using bootstrapping.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_jobs=DEFAULT\_N\_JOBS}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} If parallel processing, number of threads to use.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_sim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of simulations to bootstrap for SE estimation.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Dictionary with results of the fit and the observed correlation
matrix.

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{init\_parameter\_set() (in module glomar\_gridding.ellipse\_builder)@\spxentry{init\_parameter\_set()}\spxextra{in module glomar\_gridding.ellipse\_builder}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_builder.init_parameter_set}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.ellipse\_builder.}}\sphinxbfcode{\sphinxupquote{init\_parameter\_set}}}
{\sphinxparam{\DUrole{n}{coords}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{n}{default\_value}\DUrole{o}{=}\DUrole{default_value}{nan}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Initialise the ellipse parameter dataset.

\sphinxAtStartPar
Contains arrays for each of the parameters of the model.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coords}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.Coordinates}}) \textendash{} The coordinate system of the output arrays. Note that this should match
the coordinate system of the data used to fit the ellipse parameters.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{dict}}{[}\sphinxcode{\sphinxupquote{str}}, \sphinxcode{\sphinxupquote{str}}{]}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Default value(s) to fill arrays where parameter estimation is not
possible (typically due to masking). Typically, one should set a
value that is appropriate to the type of the field. If a single
value is provided, this is used for all fields.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{params} \textendash{} With arrays described above.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.Dataset

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.ellipse\_covariance@\spxentry{glomar\_gridding.ellipse\_covariance}}\index{glomar\_gridding.ellipse\_covariance@\spxentry{glomar\_gridding.ellipse\_covariance}!module@\spxentry{module}}

\section{Ellipse Covariance}
\label{\detokenize{users_guide:ellipse-covariance}}\label{\detokenize{users_guide:module-glomar_gridding.ellipse_covariance}}
\sphinxAtStartPar
Class to estimate covariance matrix from ellipse parameters and positions.
\index{EllipseCovarianceBuilder (class in glomar\_gridding.ellipse\_covariance)@\spxentry{EllipseCovarianceBuilder}\spxextra{class in glomar\_gridding.ellipse\_covariance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_covariance.EllipseCovarianceBuilder}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.ellipse\_covariance.}}\sphinxbfcode{\sphinxupquote{EllipseCovarianceBuilder}}}
{\sphinxparam{\DUrole{n}{Lx}}\sphinxparamcomma \sphinxparam{\DUrole{n}{Ly}}\sphinxparamcomma \sphinxparam{\DUrole{n}{theta}}\sphinxparamcomma \sphinxparam{\DUrole{n}{stdev}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lats}}\sphinxparamcomma \sphinxparam{\DUrole{n}{lons}}\sphinxparamcomma \sphinxparam{\DUrole{n}{v}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_x\_method=\textquotesingle{}Modified\_Met\_Office\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{max\_dist=6000.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{precision=\textless{}class \textquotesingle{}numpy.float32\textquotesingle{}\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{covariance\_method=\textquotesingle{}array\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{batch\_size=None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute covariance from Ellipse parameters and positions.

\sphinxAtStartPar
v = Matern covariance shape parameter

\sphinxAtStartPar
Lx \sphinxhyphen{} an numpy array of horizontal length scales (
Ly \sphinxhyphen{} an numpy array of meridonal length scales
theta \sphinxhyphen{} an numpy array of rotation angles (RADIANS ONLY)

\sphinxAtStartPar
sdev \sphinxhyphen{} standard deviation \textendash{} right now it just takes a numeric array
if you have multiple contribution to sdev (uncertainties derived from
different sources), you need to put them into one array

\sphinxAtStartPar
Rules:
Valid (ocean) point:
1) cov\_ns and cor\_ns are computed out to max\_dist; out of range = 0.0
2) Masked points are ignored

\sphinxAtStartPar
Invalid (masked) points:
1) Skipped over

\sphinxAtStartPar
max\_dist:
float (km) or (degrees if you want to work in degrees), default 6000km
if you want infinite distance, just set it to a large number, some fun
numbers to use:
\begin{itemize}
\item {}
\sphinxAtStartPar
1.5E8 (i.e. \textasciitilde{}1 astronomical unit (Earth\sphinxhyphen{}Sun distance))

\item {}
\sphinxAtStartPar
5.0E9 (average distance between Earth and not\sphinxhyphen{}a\sphinxhyphen{}planet\sphinxhyphen{}anymore Pluto)

\end{itemize}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Lx}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Arrays with non\sphinxhyphen{}stationary parameters

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Ly}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Arrays with non\sphinxhyphen{}stationary parameters

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{theta}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Arrays with non\sphinxhyphen{}stationary parameters

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stdev}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Arrays with non\sphinxhyphen{}stationary parameters

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lats}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Arrays containing the latitude and longitude values

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lons}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Arrays containing the latitude and longitude values

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{v}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Matern shape parameter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_x\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} How are displacements computed between points

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_dist}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} If the Haversine distance between 2 points exceed max\_dist,
covariance is set to 0

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{precision}} (\sphinxstyleliteralemphasis{\sphinxupquote{type}}) \textendash{} Floating point precision of the output covariance numpy defaults to
np.float32.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{covariance\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{CovarianceMethod}}) \textendash{}
\sphinxAtStartPar
Set the covariance method used:
\begin{itemize}
\item {}
\sphinxAtStartPar
array (default): faster but uses significantly more memory as
more pre\sphinxhyphen{}computation is performed. Values are computed in a
vectorised method.

\item {}
\sphinxAtStartPar
loop: slower iterative process, computes each value individually

\item {}
\sphinxAtStartPar
batched: combines the above approaches.

\end{itemize}

\sphinxAtStartPar
If the number of grid\sphinxhyphen{}points exceeds 10\_000 and “array” method is used,
the method will be overwritten to “loop”.


\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{batch\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Size of the batch to use for the “batched” method. Must be set if the
covariance\_method is set to “batched”.

\end{itemize}

\end{description}\end{quote}
\index{c\_ij\_anisotropic\_array() (glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method)@\spxentry{c\_ij\_anisotropic\_array()}\spxextra{glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_covariance.EllipseCovarianceBuilder.c_ij_anisotropic_array}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{c\_ij\_anisotropic\_array}}}
{\sphinxparam{\DUrole{n}{i\_s}}\sphinxparamcomma \sphinxparam{\DUrole{n}{j\_s}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the covariances between pairs of ellipses, at displacements.

\sphinxAtStartPar
Each ellipse is defined by values from Lxs, Lys, and thetas, with
standard deviation in stdevs.

\sphinxAtStartPar
The displacements between each pair of ellipses are x\_is and x\_js.

\sphinxAtStartPar
For N ellipses, the number of displacements should be 1/2 * N * (N \sphinxhyphen{} 1),
i.e. the displacement between each pair combination of ellipses. This
function will return the upper triangular values of the covariance
matrix (excluding the diagonal).

\sphinxAtStartPar
\sphinxtitleref{itertools.combinations} is used to handle ordering, so the
displacements must be ordered in the same way.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i\_s}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The row indices for the covariance matrix.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{j\_s}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The column indices for the covariance matrix.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{c\_ij} \textendash{} A vector containing the covariance values between each pair of
ellipses. This will return the components of the upper triangle of
the covariance matrix as a vector (excluding the diagonal).

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}
\subsubsection*{References}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Paciorek and Schevrish 2006 Equation 8 \sphinxurl{https://doi.org/10.1002/env.785}

\item {}
\sphinxAtStartPar
Karspeck et al 2012 Equation 17 \sphinxurl{https://doi.org/10.1002/qj.900}

\end{enumerate}

\end{fulllineitems}

\index{calculate\_cor() (glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method)@\spxentry{calculate\_cor()}\spxextra{glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_covariance.EllipseCovarianceBuilder.calculate_cor}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{calculate\_cor}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate correlation matrix from the covariance matrix
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_covariance\_array() (glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method)@\spxentry{calculate\_covariance\_array()}\spxextra{glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_covariance.EllipseCovarianceBuilder.calculate_covariance_array}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{calculate\_covariance\_array}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate the covariance matrix from the ellipse parameters
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_covariance\_batched() (glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method)@\spxentry{calculate\_covariance\_batched()}\spxextra{glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_covariance.EllipseCovarianceBuilder.calculate_covariance_batched}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{calculate\_covariance\_batched}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the covariance matrix from ellipse parameters, using a batched
approach.
This approach is more memory safe and appropriate for low\sphinxhyphen{}memory
operations, but is slower than self.calculate\_covariance
which uses a lot of pre\sphinxhyphen{}computation and a vectorised approach.

\sphinxAtStartPar
Each ellipse is defined by values from Lxs, Lys, and thetas, with
standard deviation in stdevs.

\sphinxAtStartPar
Requires a batch\_size parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}
\subsubsection*{References}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {}
\sphinxAtStartPar
Paciorek and Schevrish 2006 Equation 8 \sphinxurl{https://doi.org/10.1002/env.785}

\item {}
\sphinxAtStartPar
Karspeck et al 2012 Equation 17 \sphinxurl{https://doi.org/10.1002/qj.900}

\end{enumerate}

\end{fulllineitems}

\index{calculate\_covariance\_loop() (glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method)@\spxentry{calculate\_covariance\_loop()}\spxextra{glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_covariance.EllipseCovarianceBuilder.calculate_covariance_loop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{calculate\_covariance\_loop}}}
{}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the covariance matrix from ellipse parameters, using a loop.
This approach is more memory safe and appropriate for low\sphinxhyphen{}memory
operations, but is significantly slower than self.calculate\_covariance
which uses a lot of pre\sphinxhyphen{}computation and a vectorised approach.

\sphinxAtStartPar
Each ellipse is defined by values from Lxs, Lys, and thetas, with
standard deviation in stdevs.
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}
\subsubsection*{References}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Paciorek and Schevrish 2006 Equation 8 \sphinxurl{https://doi.org/10.1002/env.785}

\item {}
\sphinxAtStartPar
Karspeck et al 2012 Equation 17 \sphinxurl{https://doi.org/10.1002/qj.900}

\end{enumerate}

\end{fulllineitems}

\index{uncompress\_cov() (glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method)@\spxentry{uncompress\_cov()}\spxextra{glomar\_gridding.ellipse\_covariance.EllipseCovarianceBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.ellipse_covariance.EllipseCovarianceBuilder.uncompress_cov}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{uncompress\_cov}}}
{\sphinxparam{\DUrole{n}{diag\_fill\_value}\DUrole{o}{=}\DUrole{default_value}{nan}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fill\_value}\DUrole{o}{=}\DUrole{default_value}{nan}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert the covariance matrix to full grid size.

\sphinxAtStartPar
Optionally, fill the array with along the diagonal with a
\sphinxtitleref{diag\_fill\_value} and off the diagonal with a \sphinxtitleref{fill\_value}, which both
default to \sphinxtitleref{np.nan}.

\sphinxAtStartPar
Overwrites the \sphinxtitleref{cov\_ns} attribute.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{diag\_fill\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value to assign to diagonal masked values. Defaults to \sphinxtitleref{np.nan}

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fill\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} Value to assign to off\sphinxhyphen{}diagonal masked values. Defaults to \sphinxtitleref{np.nan}

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.covariance\_tools@\spxentry{glomar\_gridding.covariance\_tools}}\index{glomar\_gridding.covariance\_tools@\spxentry{glomar\_gridding.covariance\_tools}!module@\spxentry{module}}

\section{Covariance Tools}
\label{\detokenize{users_guide:covariance-tools}}\label{\detokenize{users_guide:module-glomar_gridding.covariance_tools}}
\sphinxAtStartPar
Repair “damaged”/”improper” covariance matrices:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Un\sphinxhyphen{}invertible covariance matrices with 0 eigenvalues

\item {}
\sphinxAtStartPar
Covariance matrices with eigenvalues less than zero

\end{enumerate}

\sphinxAtStartPar
Known causes of damage:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Multicollinearity:
but nearly all very large cov matrices will have rounding errors to have
this occur

\item {}
\sphinxAtStartPar
Number of spatial points \textgreater{}\textgreater{} length of time series
(for ESA monthly pentads: this ratio is about 150)

\item {}
\sphinxAtStartPar
Covariance is estimated using partial data

\end{enumerate}

\sphinxAtStartPar
In most cases, the most likely causes are 2 and 3.

\sphinxAtStartPar
There are a number of methods included in this module. In general, the approach
is to adjust the eigenvalues to ensure small or negative eigenvalues are
increased to some minimum threshold. The covariance matrix is then re\sphinxhyphen{}calculated
using these modified eigenvalues and the original eigenvectors.

\sphinxAtStartPar
In general, the recommended approach is Original Clipping, see
\sphinxtitleref{glomar\_gridding.covariance\_tools.eigenvalue\_clip}.

\sphinxAtStartPar
Fixes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \begin{description}
\sphinxlineitem{Simple clipping \sphinxhyphen{} \sphinxtitleref{glomar\_gridding.covariance\_tools.simple\_clipping}:}
\sphinxAtStartPar
Cut off the negative, zero, and small positive eigenvalues; this is
method used in statsmodels.stats.correlation\_tools but the version here
has better thresholds based on the accuracy of the eigenvalues, plus a
iterative version which is slower but more stable with big matrices. The
iterative version is recommended for SST/MAT covariances.

\sphinxAtStartPar
This is used for SST covariance matrices which have less dominant modes
than MAT; it also preserves more noise.

\sphinxAtStartPar
Trace (aka total variance) of the covariance matrix is not conserved,
but it is less disruptive than EOF chop off (method 3).

\sphinxAtStartPar
It is more difficult to use for covariance matrices with one large
dominant mode because that raises the bar of accuracy of the
eigenvalues, which requires clipping off a lot more eigenvectors.

\end{description}

\item {} \begin{description}
\sphinxlineitem{Original clipping \sphinxhyphen{} \sphinxtitleref{glomar\_gridding.covariance\_tools.eigenvalue\_clip}:}
\sphinxAtStartPar
Determine a noise eigenvalue threshold and replace all eigenvalues below
using the average of them, preserving the original trace (aka total
variance) of the covariance matrix, but this will require a full
computation of all eigenvectors, which may be slow and cause memory
problems

\end{description}

\item {} \begin{description}
\sphinxlineitem{EOF chop\sphinxhyphen{}off \sphinxhyphen{} \sphinxtitleref{glomar\_gridding.covariance\_tools.eof\_chop}:}
\sphinxAtStartPar
Set a target explained variance (say 95\%) for the empirical orthogonal
functions, compute the eigenvalues and eigenvectors up to that explained
variance. Reconstruct the covariance keeping only EOFs up to the target.
This is very close to 2, but it reduces the total variance of the
covariance matrix. The original method requires solving for ALL
eigenvectors which may not be possible for massive matrices
(40000x40000 square matrices). This is currently done for the MAT
covariance matrices which have very large dominant modes.

\end{description}

\item {} \begin{description}
\sphinxlineitem{Other methods not implemented here}\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} \begin{description}
\sphinxlineitem{shrinkage methods}
\sphinxAtStartPar
\sphinxurl{https://scikit-learn.org/stable/modules/covariance.html}

\end{description}

\item {} \begin{description}
\sphinxlineitem{reprojection (aka Higham’s method)}
\sphinxAtStartPar
\sphinxurl{https://github.com/mikecroucher/nearest\_correlation}
\sphinxurl{https://nhigham.com/2013/02/13/the-nearest-correlation-matrix/}

\end{description}

\end{enumerate}

\end{description}

\end{enumerate}

\sphinxAtStartPar
Author S Chan.
Modified by J. Siddons.
\index{check\_symmetric() (in module glomar\_gridding.covariance\_tools)@\spxentry{check\_symmetric()}\spxextra{in module glomar\_gridding.covariance\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.covariance_tools.check_symmetric}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.covariance\_tools.}}\sphinxbfcode{\sphinxupquote{check\_symmetric}}}
{\sphinxparam{\DUrole{n}{a}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rtol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}05}}\sphinxparamcomma \sphinxparam{\DUrole{n}{atol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}08}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Helper function for perturb\_sym\_matrix\_2\_positive\_definite
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{bool}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{clean\_small() (in module glomar\_gridding.covariance\_tools)@\spxentry{clean\_small()}\spxextra{in module glomar\_gridding.covariance\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.covariance_tools.clean_small}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.covariance\_tools.}}\sphinxbfcode{\sphinxupquote{clean\_small}}}
{\sphinxparam{\DUrole{n}{matrix}}\sphinxparamcomma \sphinxparam{\DUrole{n}{atol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}05}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Set small values (abs(x) \textless{} atol) in an matrix to 0
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{csum\_up\_to\_val() (in module glomar\_gridding.covariance\_tools)@\spxentry{csum\_up\_to\_val()}\spxextra{in module glomar\_gridding.covariance\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.covariance_tools.csum_up_to_val}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.covariance\_tools.}}\sphinxbfcode{\sphinxupquote{csum\_up\_to\_val}}}
{\sphinxparam{\DUrole{n}{vals}}\sphinxparamcomma \sphinxparam{\DUrole{n}{target}}\sphinxparamcomma \sphinxparam{\DUrole{n}{reverse}\DUrole{o}{=}\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{niter}\DUrole{o}{=}\DUrole{default_value}{0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{csum}\DUrole{o}{=}\DUrole{default_value}{0.0}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Find csum and sample index that target is surpassed. Displays a warning if
the target is not exceeded or the input \sphinxtitleref{vals} is empty.

\sphinxAtStartPar
Can provide an initial \sphinxtitleref{niter} and/or \sphinxtitleref{csum} value(s), if working with
multiple arrays in an iterative process.

\sphinxAtStartPar
If \sphinxtitleref{reverse} is set, the returned index will be negative and will correspond
to the index required for the non\sphinxhyphen{}reversed array. Reverse is the default.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vals}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Vector of values to sum cumulatively.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Value for which the cumulative sum must exceed.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reverse}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Reverse the array. The index will be negative.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{niter}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Initial number of iterations.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csum}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Initial cumulative sum value.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{float}}, \sphinxcode{\sphinxupquote{int}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{csum} (\sphinxstyleemphasis{float}) \textendash{} The cumulative sum at the index when the target has been exceeded.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{niter} (\sphinxstyleemphasis{int}) \textendash{} The index of the value that results in the cumulative sum exceeding
the target.

\end{itemize}


\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
It is actually faster to compute a full cumulative sum with \sphinxtitleref{np.cumsum} and
then look for the value that exceeds the target. This is not performed in
this function.
\end{sphinxadmonition}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{vals} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{target} \PYG{o}{=} \PYG{l+m+mf}{301.1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{csum\PYGZus{}up\PYGZus{}to\PYGZus{}val}\PYG{p}{(}\PYG{n}{vals}\PYG{p}{,} \PYG{n}{target}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{eigenvalue\_clip() (in module glomar\_gridding.covariance\_tools)@\spxentry{eigenvalue\_clip()}\spxextra{in module glomar\_gridding.covariance\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.covariance_tools.eigenvalue_clip}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.covariance\_tools.}}\sphinxbfcode{\sphinxupquote{eigenvalue\_clip}}}
{\sphinxparam{\DUrole{n}{cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}explained\_variance\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{method\_parms}\DUrole{o}{=}\DUrole{default_value}{\{\textquotesingle{}target\textquotesingle{}: 0.95\}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Denoise symmetric damaged covariance/correlation matrix cov by clipping
eigenvalues
\begin{description}
\sphinxlineitem{This is the original method:}
\sphinxAtStartPar
\sphinxurl{https://www.worldscientific.com/doi/abs/10.1142/S0219024900000255}

\end{description}

\sphinxAtStartPar
Explained variance or aspect ratio based threshold
Aspect ratios is based on dimensionless parameters
(number of independent variable and observation size)
\begin{equation*}
\begin{split}q = N/T = (num of independent variable)
/ (num of observation per independent variable)\end{split}
\end{equation*}
\sphinxAtStartPar
Does not give the same results as in eig\_clip

\sphinxAtStartPar
explained\_variance here does not have the same meaning.
The trace of a correlation, by definition, equals the number of diagonal
elements, which isn’t intituatively linked to actual explained variance
in climate science sense

\sphinxAtStartPar
This is done by KEEPING the largest explained variance
in which (number of basis vectors to be kept) \textgreater{}\textgreater{} (number of rows)
In ESA data, keeping 95\% variance means keeping top \textasciitilde{}15\% of the
eigenvalues
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Input covariance matrix to be adjusted to positive definite.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{"explained\_variance"}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{"Laloux\_2000"}}) \textendash{} Method used to identify the index of the eigenvalues to clip.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{cov\_adj} \textendash{} Adjusted covariance matrix.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{eof\_chop() (in module glomar\_gridding.covariance\_tools)@\spxentry{eof\_chop()}\spxextra{in module glomar\_gridding.covariance\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.covariance_tools.eof_chop}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.covariance\_tools.}}\sphinxbfcode{\sphinxupquote{eof\_chop}}}
{\sphinxparam{\DUrole{n}{cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{target\_explained\_variance}\DUrole{o}{=}\DUrole{default_value}{0.95}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Re\sphinxhyphen{}compute the covariance using only eigenvectors associated with the
largest eigenvalues such that the explained variance achieves a target
value.

\sphinxAtStartPar
This method is similar to a standard eigenvalue clipping method, however
only the eigenvectors associated with the largest eigenvalues are computed,
saving on memory and improves time execution. This method is best suited to
larger covariance matrices, for example those for a 1\sphinxhyphen{}degree resolution
grid (approx 40\_000 x 40\_000). This is also appropriate for covariance
matrices with very large dominant modes.

\sphinxAtStartPar
This method does not preserve the total variance, i.e. the trace of the
output covariance matrix may not match the input.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Input covariance matrix to be adjusted to positive definite.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_explained\_variance}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Select only the largest eigenvalues such that the explained variance of
these eigenvalues is \textless{}= this value. The eigenvalues are first sorted in
descending order, then cumulatively summed. Eigenvalues that correspond
to values in the cumulative sum above this explained variance are
dropped.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{dict}}{[}\sphinxcode{\sphinxupquote{str}}, \sphinxcode{\sphinxupquote{Any}}{]}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{cov\_adj} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Adjusted covariance matrix

\item {}
\sphinxAtStartPar
\sphinxstylestrong{summary\_dict} (\sphinxstyleemphasis{dict{[}str, Any{]}}) \textendash{} A dictionary containing a summary of the input and results with the
following keys:
\begin{itemize}
\item {}
\sphinxAtStartPar
”target\_explained\_variance\%”

\item {}
\sphinxAtStartPar
”num\_of\_retained\_eofs”

\item {}
\sphinxAtStartPar
”threshold”

\item {}
\sphinxAtStartPar
”smallest\_eigv”

\item {}
\sphinxAtStartPar
”largest\_eigv”

\item {}
\sphinxAtStartPar
”determinant”

\item {}
\sphinxAtStartPar
”total\_variance”

\end{itemize}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{perturb\_cov\_to\_positive\_definite() (in module glomar\_gridding.covariance\_tools)@\spxentry{perturb\_cov\_to\_positive\_definite()}\spxextra{in module glomar\_gridding.covariance\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.covariance_tools.perturb_cov_to_positive_definite}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.covariance\_tools.}}\sphinxbfcode{\sphinxupquote{perturb\_cov\_to\_positive\_definite}}}
{\sphinxparam{\DUrole{n}{cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}15}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Force an estimated covariance matrix to be positive definite using the
eigenvalue clipping with statsmodels.stats.correlation\_tools.cov\_nearest
function.

\sphinxAtStartPar
Deprecated in favour of glomar\_gridding.covariance\_tools.simple\_clipping.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The estimated covariance matrix that is not positive definite.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}auto\textquotesingle{}}}) \textendash{} Eigenvalues below this value are set to 0. If the input is ‘auto’ then
the value is determined using the floating\sphinxhyphen{}point precision and magnitude
of the largest eigenvalues.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{cov\_adj} \textendash{} Adjusted covariance matrix

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray

\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Use}}


\end{sphinxseealso}

\subsubsection*{Notes}
\begin{description}
\sphinxlineitem{Other methods:}
\sphinxAtStartPar
\sphinxurl{https://nhigham.com/2021/02/16/diagonally-perturbing-a-symmetric-matrix-to-make-it-positive-definite/}
\sphinxurl{https://nhigham.com/2013/02/13/the-nearest-correlation-matrix/}
\sphinxurl{https://academic.oup.com/imajna/article/22/3/329/708688}

\end{description}

\end{fulllineitems}

\index{simple\_clipping() (in module glomar\_gridding.covariance\_tools)@\spxentry{simple\_clipping()}\spxextra{in module glomar\_gridding.covariance\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.covariance_tools.simple_clipping}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.covariance\_tools.}}\sphinxbfcode{\sphinxupquote{simple\_clipping}}}
{\sphinxparam{\DUrole{n}{cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}auto\textquotesingle{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}iterative\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
A modified version of:
\sphinxurl{https://www.statsmodels.org/dev/generated/statsmodels.stats.correlation\_tools.corr\_nearest.html}

\sphinxAtStartPar
Force an estimated covariance matrix to be positive definite using the
eigenvalue clipping with statsmodels.stats.correlation\_tools.cov\_nearest
function.

\sphinxAtStartPar
This is appropriate for covariance matrices which have less dominant modes;
it also preserves more noise.

\sphinxAtStartPar
Trace (aka total variance) of the covariance matrix is not conserved,
but it is less disruptive than EOF chop off.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The estimated covariance matrix that is not positive definite.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}auto\textquotesingle{}}}) \textendash{} Eigenvalues below this value are set to 0. If the input is ‘auto’ then
the value is determined using the floating\sphinxhyphen{}point precision and magnitude
of the largest eigenvalues.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{ndarray}}, \sphinxcode{\sphinxupquote{dict}}{[}\sphinxcode{\sphinxupquote{str}}, \sphinxcode{\sphinxupquote{Any}}{]}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{cov\_adj} (\sphinxstyleemphasis{numpy.ndarray}) \textendash{} Adjusted covariance matrix

\item {}
\sphinxAtStartPar
\sphinxstylestrong{summary\_dict} (\sphinxstyleemphasis{dict{[}str, Any{]}}) \textendash{} A dictionary containing a summary of the input and results with the
following keys:
\begin{itemize}
\item {}
\sphinxAtStartPar
”threshold”

\item {}
\sphinxAtStartPar
”smallest\_eigv”

\item {}
\sphinxAtStartPar
”determinant”

\item {}
\sphinxAtStartPar
”total\_variance”

\end{itemize}

\end{itemize}


\end{description}\end{quote}


\begin{sphinxseealso}{See also:}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{statsmodels.stats.correlation\_tools.cov\_nearest}}


\end{sphinxseealso}

\subsubsection*{Notes}

\sphinxAtStartPar
Other methods:
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxurl{https://nhigham.com/2021/02/16/diagonally-perturbing-a-symmetric-matrix-to-make-it-positive-definite/}

\item {}
\sphinxAtStartPar
\sphinxurl{https://nhigham.com/2013/02/13/the-nearest-correlation-matrix/}

\item {}
\sphinxAtStartPar
\sphinxurl{https://academic.oup.com/imajna/article/22/3/329/708688}

\end{itemize}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.perturbation@\spxentry{glomar\_gridding.perturbation}}\index{glomar\_gridding.perturbation@\spxentry{glomar\_gridding.perturbation}!module@\spxentry{module}}\phantomsection\label{\detokenize{users_guide:module-glomar_gridding.perturbation}}
\sphinxAtStartPar
Functions for helping with perturbations/random drawing
\index{scipy\_mv\_normal\_draw() (in module glomar\_gridding.perturbation)@\spxentry{scipy\_mv\_normal\_draw()}\spxextra{in module glomar\_gridding.perturbation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.perturbation.scipy_mv_normal_draw}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.perturbation.}}\sphinxbfcode{\sphinxupquote{scipy\_mv\_normal\_draw}}}
{\sphinxparam{\DUrole{n}{loc}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ndraws}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{eigen\_rtol}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}\sphinxparamcomma \sphinxparam{\DUrole{n}{eigen\_fudge}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}08}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Do a random multivariate normal draw using
scipy.stats.multivariate\_normal.rvs

\sphinxAtStartPar
numpy.random.multivariate\_normal can also,
but fixing seeds are more difficult using numpy

\sphinxAtStartPar
This function has similar API as GP\_draw with less kwargs.

\sphinxAtStartPar
Warning/possible future scipy version may change this:
It seems if one uses stats.Covariance, you have to have add {[}0{]} from rvs
function. The above behavior applies to scipy v1.14.0
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loc}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the location for the normal dry

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} not a xarray/iris cube! Some of our covariances are saved in numpy
format and not netCDF files

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_draws}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of simulations, this is usually set to 1 except during

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{testing}} (\sphinxstyleliteralemphasis{\sphinxupquote{unit}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eigen\_rtol}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} relative tolerance to negative eigenvalues

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eigen\_fudge}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} forced minimum value of eigenvalues if negative values are detected

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{draw} \textendash{} The draw(s) from the multivariate random normal distribution defined
by the loc and cov parameters. If the cov parameter is not
positive\sphinxhyphen{}definite then a new covariance will be determined by adjusting
the eigen decomposition such that the modified covariance should be
positive\sphinxhyphen{}definite.

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{module@\spxentry{module}!glomar\_gridding.utils@\spxentry{glomar\_gridding.utils}}\index{glomar\_gridding.utils@\spxentry{glomar\_gridding.utils}!module@\spxentry{module}}\phantomsection\label{\detokenize{users_guide:module-glomar_gridding.utils}}
\sphinxAtStartPar
Utility functions for GloMarGridding
\index{ColumnNotFoundError@\spxentry{ColumnNotFoundError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.ColumnNotFoundError}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{exception}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{ColumnNotFoundError}}}
\pysigstopsignatures
\sphinxAtStartPar
Error class for Column Not Being Found

\end{fulllineitems}

\index{ConfigParserMultiValues (class in glomar\_gridding.utils)@\spxentry{ConfigParserMultiValues}\spxextra{class in glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.ConfigParserMultiValues}}
\pysigstartsignatures
\pysigline
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{ConfigParserMultiValues}}}
\pysigstopsignatures
\sphinxAtStartPar
Internal Helper Class

\end{fulllineitems}

\index{MonthName (class in glomar\_gridding.utils)@\spxentry{MonthName}\spxextra{class in glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.MonthName}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxbfcode{\sphinxupquote{\DUrole{k}{class}\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{MonthName}}}
{\sphinxparam{\DUrole{n}{value}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Name of month from int

\end{fulllineitems}

\index{add\_empty\_layers() (in module glomar\_gridding.utils)@\spxentry{add\_empty\_layers()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.add_empty_layers}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{add\_empty\_layers}}}
{\sphinxparam{\DUrole{n}{nc\_variables}}\sphinxparamcomma \sphinxparam{\DUrole{n}{timestamps}}\sphinxparamcomma \sphinxparam{\DUrole{n}{shape}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Add empty layers to a netcdf file. This adds a layer of zeros to the netCDF
file.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nc\_variables}} (\sphinxstyleliteralemphasis{\sphinxupquote{Iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{nc.Variable}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{nc.Variable}}) \textendash{} Name(s) of the variables to add empty layers to

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestamps}} (\sphinxstyleliteralemphasis{\sphinxupquote{Iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{| }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Indices to add empty layers

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shape}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Shape of the layer to add

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{adjust\_small\_negative() (in module glomar\_gridding.utils)@\spxentry{adjust\_small\_negative()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.adjust_small_negative}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{adjust\_small\_negative}}}
{\sphinxparam{\DUrole{n}{mat}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Adjusts small negative values (with absolute value \textless{} 1e\sphinxhyphen{}8)
in matrix to 0 in\sphinxhyphen{}place.

\sphinxAtStartPar
Raises a warning if any small negative values are detected.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mat}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Squared uncertainty associated with chosen kriging method
Derived from the diagonal of the matrix

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{batched() (in module glomar\_gridding.utils)@\spxentry{batched()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.batched}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{batched}}}
{\sphinxparam{\DUrole{n}{iterable}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n}}\sphinxparamcomma \sphinxparam{\DUrole{keyword-only-separator}{\DUrole{o}{\sphinxstyleabbreviation{*} (Keyword\sphinxhyphen{}only parameters separator (PEP 3102))}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{strict}\DUrole{o}{=}\DUrole{default_value}{False}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Implementation of itertools.batched for use if python version is \textless{} 3.12.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{batched}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ABCDEFG}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[(\PYGZdq{}A\PYGZdq{}, \PYGZdq{}B\PYGZdq{}, \PYGZdq{}C\PYGZdq{}), (\PYGZdq{}D\PYGZdq{}, \PYGZdq{}E\PYGZdq{}, \PYGZdq{}F\PYGZdq{}), (\PYGZdq{}G\PYGZdq{}, )]}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{check\_cols() (in module glomar\_gridding.utils)@\spxentry{check\_cols()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.check_cols}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{check\_cols}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{cols}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Check that all columns in a list of columns are in a DataFrame
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{None}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{cor\_2\_cov() (in module glomar\_gridding.utils)@\spxentry{cor\_2\_cov()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.cor_2_cov}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{cor\_2\_cov}}}
{\sphinxparam{\DUrole{n}{cor}}\sphinxparamcomma \sphinxparam{\DUrole{n}{variances}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rounding}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Compute covariance matrix from correlation matrix and variances
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cor}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Correlation Matrix

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{variances}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Variances to scale the correlation matrix.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rounding}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} round the values of the output

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{cov\_2\_cor() (in module glomar\_gridding.utils)@\spxentry{cov\_2\_cor()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.cov_2_cor}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{cov\_2\_cor}}}
{\sphinxparam{\DUrole{n}{cov}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rounding}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Normalises the covariance matrices within the class instance
and return correlation matrices
\sphinxurl{https://gist.github.com/wiso/ce2a9919ded228838703c1c7c7dad13b}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cov}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} Covariance matrix

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rounding}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} round the values of the output

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{days\_since\_by\_month() (in module glomar\_gridding.utils)@\spxentry{days\_since\_by\_month()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.days_since_by_month}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{days\_since\_by\_month}}}
{\sphinxparam{\DUrole{n}{year}}\sphinxparamcomma \sphinxparam{\DUrole{n}{day}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get the number of days since \sphinxtitleref{year}\sphinxhyphen{}01\sphinxhyphen{}\sphinxtitleref{day} for each month. This is used
to set the time values in a netCDF file where temporal resolution is monthly
and the units are days since some date.
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{ndarray}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{deg\_to\_km() (in module glomar\_gridding.utils)@\spxentry{deg\_to\_km()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.deg_to_km}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{deg\_to\_km}}}
{\sphinxparam{\DUrole{n}{deg}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
deg: float (degrees)
Convert degree latitude change to km
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{float}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{deg\_to\_nm() (in module glomar\_gridding.utils)@\spxentry{deg\_to\_nm()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.deg_to_nm}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{deg\_to\_nm}}}
{\sphinxparam{\DUrole{n}{deg}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
deg: float (degrees)
Convert degree latitude change to nautical miles
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{float}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_bounds() (in module glomar\_gridding.utils)@\spxentry{filter\_bounds()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.filter_bounds}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{filter\_bounds}}}
{\sphinxparam{\DUrole{n}{df}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bounds}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bound\_cols}}\sphinxparamcomma \sphinxparam{\DUrole{n}{closed}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}left\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Filter a polars DataFrame based on a set of lower and upper bounds.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{polars.DataFrame}}) \textendash{} The data to be filtered by the bounds

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list of tuples containing lower and upper bounds for a column

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bound\_cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list of column names to be filtered by the bounds, the length of
the bounds list must equal the length of the bound\_cols list.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{closed}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} One of “both”, “left”, “right”, “none” indicating the closedness of
the bounds. If the input is a single instance then all bounds will have
that closedness. If it is a list of closed values then its length must
match the length of the bounds list.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{DataFrame}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_nearest() (in module glomar\_gridding.utils)@\spxentry{find\_nearest()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.find_nearest}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{find\_nearest}}}
{\sphinxparam{\DUrole{n}{array}}\sphinxparamcomma \sphinxparam{\DUrole{n}{values}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get the indices and values from an array that are closest to the input
values.

\sphinxAtStartPar
A single index, value pair is returned for each look\sphinxhyphen{}up value in the values
list.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{array}} (\sphinxstyleliteralemphasis{\sphinxupquote{Iterable}}) \textendash{} The array to search for nearest values.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{Iterable}}) \textendash{} The values to look\sphinxhyphen{}up in the array.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{list}}{[}\sphinxcode{\sphinxupquote{int}}{]}, \sphinxcode{\sphinxupquote{ndarray}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{idx\_list} (\sphinxstyleemphasis{list{[}int{]}}) \textendash{} The indices of nearest values

\item {}
\sphinxAtStartPar
\sphinxstylestrong{array\_values\_list} (\sphinxstyleemphasis{list}) \textendash{} The list of values in array that are closest to the input values.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_date\_index() (in module glomar\_gridding.utils)@\spxentry{get\_date\_index()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.get_date_index}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{get\_date\_index}}}
{\sphinxparam{\DUrole{n}{year}}\sphinxparamcomma \sphinxparam{\DUrole{n}{month}}\sphinxparamcomma \sphinxparam{\DUrole{n}{start\_year}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get the index of a given year\sphinxhyphen{}month in a monthly sequence of dates
starting from month 1 in a specific start year
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{year}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The year for the date to find the index of.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{month}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The month for the date to find the index of.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{start\_year}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The start year of the date series, the result assumes that the date
time series starts in the first month of this year.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{index} \textendash{} The index of the input date in the monthly datetime series starting from
the first month of year \sphinxtitleref{start\_year}.

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_month\_midpoint() (in module glomar\_gridding.utils)@\spxentry{get\_month\_midpoint()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.get_month_midpoint}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{get\_month\_midpoint}}}
{\sphinxparam{\DUrole{n}{dates}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get the month midpoint for a series of datetimes.

\sphinxAtStartPar
The midpoint of a month is the exact half\sphinxhyphen{}way point between the start and
end of the month.

\sphinxAtStartPar
For example, the midpoint of January 1990 is 1990\sphinxhyphen{}01\sphinxhyphen{}16 12:00.
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{Series}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pentad\_range() (in module glomar\_gridding.utils)@\spxentry{get\_pentad\_range()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.get_pentad_range}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{get\_pentad\_range}}}
{\sphinxparam{\DUrole{n}{centre\_date}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Get the start and date of a pentad centred at a centre date. If the
pentad includes the leap date of 29th Feb then the pentad will include
6 days. This follows the \sphinxstylestrong{*} pentad convention.

\sphinxAtStartPar
The start and end date are first calculated from a non\sphinxhyphen{}leap year.

\sphinxAtStartPar
If the centre date value is 29th Feb then the pentad will be a pentad
starting on 27th Feb and ending on 2nd March.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{centre\_date}} (\sphinxstyleliteralemphasis{\sphinxupquote{datetime.date}}) \textendash{} The centre date of the pentad. The start date will be 2 days before this
date, and the end date will be 2 days after.

\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{tuple}}{[}\sphinxcode{\sphinxupquote{date}}, \sphinxcode{\sphinxupquote{date}}{]}}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{start\_date} (\sphinxstyleemphasis{datetime.date}) \textendash{} Two days before centre\_date

\item {}
\sphinxAtStartPar
\sphinxstylestrong{end\_date} (\sphinxstyleemphasis{datetime.date}) \textendash{} Two days after centre\_date

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{init\_logging() (in module glomar\_gridding.utils)@\spxentry{init\_logging()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.init_logging}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{init\_logging}}}
{\sphinxparam{\DUrole{n}{file}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{level}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}DEBUG\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Initialise the logger
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} File to send log messages to. If set to None (default) then print log
messages to STDout

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{level}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Level of logging, one of: “debug”, “info”, “warn”, “error”, “critical”.

\end{itemize}

\sphinxlineitem{Return type}
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{intersect\_mtlb() (in module glomar\_gridding.utils)@\spxentry{intersect\_mtlb()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.intersect_mtlb}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{intersect\_mtlb}}}
{\sphinxparam{\DUrole{n}{a}}\sphinxparamcomma \sphinxparam{\DUrole{n}{b}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Returns data common between two arrays, a and b, in a sorted order and index
vectors for a and b arrays Reproduces behaviour of Matlab’s intersect
function.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{array}} (\sphinxstyleliteralemphasis{\sphinxupquote{b}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} 1\sphinxhyphen{}D}})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{array}}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{1\sphinxhyphen{}D array, c, of common values found in two arrays, a and b, sorted in order}

\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{List of indices, where the common values are located, for array a}

\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{List of indices, where the common values are located, for array b}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{is\_iter() (in module glomar\_gridding.utils)@\spxentry{is\_iter()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.is_iter}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{is\_iter}}}
{\sphinxparam{\DUrole{n}{val}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Determine if a value is an iterable
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{bool}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{km\_to\_deg() (in module glomar\_gridding.utils)@\spxentry{km\_to\_deg()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.km_to_deg}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{km\_to\_deg}}}
{\sphinxparam{\DUrole{n}{km}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
km: float (km)
Convert meridonal km change to degree latitude
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{float}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_array() (in module glomar\_gridding.utils)@\spxentry{mask\_array()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.mask_array}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{mask\_array}}}
{\sphinxparam{\DUrole{n}{arr}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Forces numpy array to be an instance of np.ma.MaskedArray
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{arr}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Can be masked or not masked

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{arr} \textendash{} array is now an instance of np.ma.MaskedArray

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{select\_bounds() (in module glomar\_gridding.utils)@\spxentry{select\_bounds()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.select_bounds}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{select\_bounds}}}
{\sphinxparam{\DUrole{n}{x}}\sphinxparamcomma \sphinxparam{\DUrole{n}{bounds}\DUrole{o}{=}\DUrole{default_value}{{[}(\sphinxhyphen{}90, 90), (\sphinxhyphen{}180, 180){]}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{variables}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}lat\textquotesingle{}, \textquotesingle{}lon\textquotesingle{}{]}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Filter an xarray.DataArray or xarray.Dataset by a set of bounds.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{xarray.DataArray}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{xarray.Dataset}}) \textendash{} The data to filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list of tuples containing the lower and upper bounds for each
dimension.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{variables}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Names of the dimensions (the order must match the bounds).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{x} \textendash{} The input data filtered by the bounds.

\sphinxlineitem{Return type}
\sphinxAtStartPar
xarray.DataArray | xarray.Dataset

\end{description}\end{quote}

\end{fulllineitems}

\index{sizeof\_fmt() (in module glomar\_gridding.utils)@\spxentry{sizeof\_fmt()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.sizeof_fmt}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{sizeof\_fmt}}}
{\sphinxparam{\DUrole{n}{num}}\sphinxparamcomma \sphinxparam{\DUrole{n}{suffix}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}B\textquotesingle{}}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Convert numbers to kilo/mega… bytes,
for interactive printing of code progress
\begin{quote}\begin{description}
\sphinxlineitem{Return type}
\sphinxAtStartPar
\DUrole{sphinx_autodoc_typehints-type}{\sphinxcode{\sphinxupquote{str}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{uncompress\_masked() (in module glomar\_gridding.utils)@\spxentry{uncompress\_masked()}\spxextra{in module glomar\_gridding.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{users_guide:glomar_gridding.utils.uncompress_masked}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{glomar\_gridding.utils.}}\sphinxbfcode{\sphinxupquote{uncompress\_masked}}}
{\sphinxparam{\DUrole{n}{compressed\_array}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mask}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fill\_value}\DUrole{o}{=}\DUrole{default_value}{0.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{apply\_mask}\DUrole{o}{=}\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{dtype}\DUrole{o}{=}\DUrole{default_value}{None}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Un\sphinxhyphen{}compress a compressed array using a mask.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{compressed\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The compressed array, originally compressed by the mask

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} The mask \sphinxhyphen{} a boolean numpy array

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fill\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} The value to fill masked points. If \sphinxtitleref{apply\_mask} is set, then this will
be removed in the output.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{apply\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Apply the mask to the result, returning a MaskedArray rather than a
ndarray.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{type}}\sphinxstyleliteralemphasis{\sphinxupquote{ | }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} Optionally set a dtype for the returned array, if not set then the
dtype of the compressed\_array is used.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
\sphinxstylestrong{uncompressed} \textendash{} The uncompressed array, masked points are filled with the fill\_value if
apply\_mask is False. If apply\_mask is True, then the result is an
instance of numpy.ma.MaskedArray with the mask applied to the
uncompressed result.

\sphinxlineitem{Return type}
\sphinxAtStartPar
numpy.ndarray | numpy.ma.MaskedArray

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{g}
\item\relax\sphinxstyleindexentry{glomar\_gridding.climatology}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.climatology}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.covariance\_tools}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.covariance_tools}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.distances}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.distances}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.ellipse}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.ellipse}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.ellipse\_builder}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.ellipse_builder}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.ellipse\_covariance}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.ellipse_covariance}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.error\_covariance}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.error_covariance}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.grid}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.grid}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.interpolation\_covariance}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.interpolation_covariance}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.kriging}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.kriging}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.mask}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.mask}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.perturbation}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.perturbation}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.utils}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.utils}}
\item\relax\sphinxstyleindexentry{glomar\_gridding.variogram}\sphinxstyleindexpageref{users_guide:\detokenize{module-glomar_gridding.variogram}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
